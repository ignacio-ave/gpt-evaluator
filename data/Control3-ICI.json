[[[
    "TORO MUNDACA",
    "RICARDO BASTIAN",
    "ricardo.toro.m@mail.pucv.cl",
    "En curso",
    "19 de mayo de 2023  14:55",
    "-",
    "-",
    "-",
    "Es recomendable usar colas con prioridad cuando todos los elementos tienen la misma prioridad",
    "Falso",
    "El árbol B\/B+ es útil para la implementación de algoritmos de búsqueda en grafos, ya que permite una rápida búsqueda de nodos y aristas",
    "Falso",
    "Se puede usar grafos para modelar sistemas de recomendación, como en aplicaciones de comercio electrónico o de películas, ya que los grafos pueden representar las preferencias de los usuarios y las relaciones entre productos o películas",
    "Verdadero",
    "Al igual que un montículo, un árbol AVL también se podría implementar usando un arreglo.",
    "Verdadero",
    "En un árbol B, la operación de búsqueda tiene una complejidad de tiempo constante, independientemente del número de elementos almacenados en el árbol",
    "Falso",
    "La búsqueda en anchura utiliza una cola para almacenar los nodos a visitar.",
    "Verdadero",
    "Las tablas hash son más eficientes que los arreglos y las listas enlazadas para buscar elementos en la estructura",
    "Verdadero",
    "La búsqueda de un elemento en un montículo tiene complejidad O(n)",
    "Verdadero",
    "La búsqueda en un árbol B tiene complejidad temporal O(n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "Considere un conjunto de estudiantes con sus respectivas calificaciones. ¿Cómo podría usar una cola de prioridad para identificar rápidamente a los 5 estudiantes con las calificaciones más altas?",
    "-",
    "Tenemos un mapa de empleados, cada uno con una lista de proyectos en los que han trabajado y el tiempo que dedicaron a cada uno. ¿Cómo podría implementar una función para encontrar el empleado que ha dedicado más tiempo a los proyectos?",
    "-",
    "Explique cómo podría implementar una cola con prioridad, usando 2 pilas. ¿Como realizaría inserciones y eliminaciones en la cola con prioridad?",
    "-"
],[
    "LEIVA CATALDO",
    "NEHEMIAS JOEL",
    "leivanehemias64@gmail.com",
    "Finalizado",
    "19 de mayo de 2023  08:12",
    "19 de mayo de 2023  08:42",
    "29 minutos 59 segundos",
    "Sin calificar aún",
    "Las colas con prioridad pueden ser implementadas utilizando diferentes estructuras de datos, como montículos o listas enlazadas",
    "Verdadero",
    "Los árboles B+ son utilizados para mejorar el rendimiento de la búsqueda secuencial en disco",
    "Verdadero",
    "Se puede usar grafos para modelar sistemas de recomendación, como en aplicaciones de comercio electrónico o de películas, ya que los grafos pueden representar las preferencias de los usuarios y las relaciones entre productos o películas",
    "Verdadero",
    "Un montículo binario puede ser implementado utilizando un arreglo.",
    "Verdadero",
    "En un árbol B+, las hojas contienen todos los datos almacenados en el árbol, mientras que los nodos internos solo contienen claves para dividir los datos en subárboles",
    "Verdadero",
    "La búsqueda en anchura encuentra la solución óptima para problemas de camino más corto.",
    "Verdadero",
    "Las listas enlazadas son más eficientes que los arreglos para insertar o eliminar elementos en posiciones aleatorias de la estructura",
    "Verdadero",
    "El orden en que se ingresan los elementos en un montículo binario no afecta su complejidad temporal, ya que siempre se cumple la propiedad del montículo",
    "Falso",
    "La complejidad espacial de un árbol B+ es mayor que la de un árbol B debido a que los nodos internos almacenan más claves.",
    "Falso",
    "Teniendo un mapa de estudiantes donde la clave es el número de matrícula y el valor es la nota final. ¿Cómo podrías calcular la nota promedio de todos los estudiantes?",
    "1. Se puede hacer una función que recorre el mapa, mientras le va sumando a una variable auxiliar la nota final de todos los estudiantes, a la vez que suma 1 a un contador por cada iteración(para obtener el numero de estudiantes).\n2. Finalmente la variable auxiliar se divide por el contador y así obtendrá el promedio.",
    "Tenemos un mapa de libros, donde cada libro tiene una lista de reseñas de usuarios. ¿Cómo podríamos calcular el número de usuarios que han calificado el libro \"Cien años de soledad\" con 5 estrellas?",
    "1. Buscamos el libro \"Cien años de soledad\" en el mapa, usando su clave correspondiente (o recorriéndolo, que es mas ineficiente).\n2. Luego creamos una variable auxiliar=0 que al recorrer la lista, se le agregue 1 por cada reseña con 5 estrellas.\n\n3. Al terminar de iterar, retornar la variable auxiliar con la cantidad de usuarios buscada.",
    "Dado un laberinto representado como una matriz de celdas, describe un algoritmo que encuentre un camino desde la entrada hasta la salida utilizando una pila.",
    "1. Se creara una pila que almacenara cada posición que se puede avanzar en un camino determinado, además de un contador para saber cuantos movimientos hizo.\n2. Si este camino no conduce a la salida, se le hará pop a los últimos elementos de la pila hasta volver a una casilla que permita mas de un movimiento (para cambiar de camino).\n3. Si logra llegar hasta la salida, se guardara toda esta pila en dentro de otra estructura arbitraria(arreglo, lista, etc.) \n4. Luego se volverá a empezar otro recorrido en la matriz desde la ultima posición en la que la pila tuvo la opción de hacer mas de un movimiento, pero esta vez tomando otro camino, si no llega a una salida, se le hará pop hasta otra posición de múltiple opción(para no repetirse) y seguira intentando.\n5. Todos los intentos se comparan al final."
],[
    "VILLAMAYOR PERALTA",
    "JOSE ARCANGEL",
    "jose.villamayor.p@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:50",
    "19 de mayo de 2023  15:16",
    "26 minutos 28 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos se eliminan en función de su orden de llegada",
    "Falso",
    "El árbol B\/B+ es útil para la implementación de algoritmos de búsqueda en grafos, ya que permite una rápida búsqueda de nodos y aristas",
    "Falso",
    "Se puede usar grafos para modelar relaciones entre entidades, ya que los grafos permiten representar de forma clara y concisa las relaciones complejas entre elementos",
    "Verdadero",
    "Un montículo binario es una estructura de datos que permite mantener una colección de elementos ordenados en función de su valor, con una complejidad de tiempo logarítmica para las operaciones de inserción, eliminación y búsqueda",
    "Falso",
    "En un árbol B, los nodos pueden tener más de dos hijos",
    "Verdadero",
    "La búsqueda en profundidad es más eficiente que la búsqueda en anchura en grafos profundos.",
    "Verdadero",
    "A diferencia de las listas enlazadas, los arreglos tienen acceso aleatorio a sus elementos",
    "Falso",
    "La altura máxima de un montículo binario con n elementos es log₂(n)",
    "Verdadero",
    "La inserción en un árbol B+ tiene complejidad temporal O(log n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "Tenemos una lista de productos con su precio y categoría. ¿Cómo podríamos calcular el precio promedio por categoría usando un mapa?",
    "1ro se obtiene de la lista el valor y la categoria que corresponde, estos se almacenan en el mapa siendo el valor de la suma de la categoria y su clave es la categoria qu corresponde, con la ayuda de contadores se puede saber cuantas veces aparecio x categoria y despues gracias a que se guardo la suma total, se divide en el respectivo contador de las veces que apareció y se obtiene el promedio de precios más el nombre de la categoria con el que estaba asignado en el mapa.",
    "Tenemos un mapa de productos, donde cada producto tiene una lista de precios de diferentes proveedores. ¿Cómo podría implementar una función para encontrar el proveedor más barato para cada producto?",
    "Asumiendo que la clave es el el nombre del producto y que el valor es una struct con las lista de precios con cada proveedor. Para saber el promedio del precio más barato, se tiene  1ro recorrer el mapa ingresando a cada precio de ese producto y guardarlo es un struct aparte indicando el precio acumulado y el proveedor, además de un contador para saber cuantas veces aparecio ese proveedor, se avanza en el mapa y se sigue sumando los valores y aumentando el cont respectivo, al final se calcula el promedio con la suma total dividido en el contador. ",
    "Explique un algoritmo que permita calcular la profundidad de un árbol binario utilizando una pila. La profundidad de un árbol binario es la longitud del camino más largo desde la raíz hasta una hoja.",
    "Se inicia una pila y se empieza por la raiz del arbol, se agrega a la pila el nodo actual, seguido se hace un algoritmo que baje por la rama más profunda y por cada nodo visitado no nulo se agrega a la pila (el algoritmo baja por la rama en forma directa al fondo), cuando el algoritmo haya llegado al ultimo nodo, solo queda contar la cantidad de nodos almacenados en la pila y así se sabe cual es la profundidad del árbol."
],[
    "TOLEDO MAC-LEAN",
    "CLAUDIO PATRICIO",
    "ctoledomaclean@gmail.com",
    "Finalizado",
    "19 de mayo de 2023  15:04",
    "19 de mayo de 2023  15:25",
    "21 minutos 19 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, es posible tener elementos con la misma prioridad pero con diferentes tiempos de llegada",
    "Verdadero",
    "En un árbol B, la inserción siempre se realiza en las hojas. (Aunque luego es posible que el nuevo dato suba a causa de una división de nodos)",
    "Verdadero",
    "Un grafo es útil cuando queremos analizar patrones de tráfico en internet, ya que los grafos pueden representar los flujos de datos entre diferentes sistemas y los nodos críticos en la red",
    "Verdadero",
    "Un montículo binario es una estructura de datos inmutable, es decir, una vez que se crea un montículo, no se pueden realizar modificaciones en su contenido",
    "Verdadero",
    "En un árbol B+, las hojas contienen todos los datos almacenados en el árbol, mientras que los nodos internos solo contienen claves para dividir los datos en subárboles",
    "Verdadero",
    "La búsqueda en profundidad es más eficiente que la búsqueda en anchura en grafos profundos.",
    "Falso",
    "Las tablas hash son más eficientes que los arreglos y las listas enlazadas para buscar elementos en la estructura",
    "Verdadero",
    "La complejidad espacial de un montículo binario es O(n), ya que todos los elementos se almacenan en el árbol",
    "Verdadero",
    "La complejidad temporal de la inserción en un árbol B es O(1)",
    "Verdadero",
    "¿Cómo implementaría una cola de prioridad para administrar las solicitudes de atención al cliente en un sistema de soporte técnico, donde los clientes VIP tienen la más alta prioridad, seguidos por los clientes habituales y luego los nuevos clientes?",
    "al implementar una cola de prioridad dependiendo de que tipo de cliente le asigno mas o menos prioridad ya sea un numero alto para los que sean clientes vip un numero de bajo para los nuevos clientes, ordeno las prioridades como maximo dejando a los clientes vip como los que tienen mas prioridad a la hora de ser atendidos. Implementamos la cola de un heap que vaya almacenando el tipo de de cliente y se le asigna la prioridad a este mismo.",
    "Supongamos que tenemos un mapa de autores, donde cada autor tiene una lista de libros que ha escrito. Cada libro incluye título, género y calificación promedio. ¿Cómo implementarías una función para calcular la calificación promedio de los libros del género de aventuras?",
    "en la funcion lo que se va hacer es recorrer el mapa, por los nombres del autor, como en la funcion especificamente se da el \"genero de aventuras\", por cada autor se va a ver de genero es el libro y si el genero del libro corresponde al genero buscado, se va a guardar en una variable axiliar, la calificacion de ese libro, asi con todos los libros que contengan ese genero se ira sumando la calificacion, mietras se van sumando las calificaciones al mismo tiempo hay una variable contador la cual ira contando las veces que se van sumando las calificaiones, asi cuando termine de recorrer el mapa, se divide la variable que va sumando las calificaciones con el contador que fue contando cuantas veces se sumo para de esta forma sacar el promedio de calificacion de ese genero en especifico",
    "Describa un algoritmo para implementar una pila utilizando dos colas.",
    "Crear dos colas, que llamaremos \"cola1\" y \"cola2\" Para realizar la operación de \"push\" en la pila vamos agregar el elemento al final de la \"cola1\" para realizar la operación de \"pop\" en la pila vamos a mover todos los elementos de la \"cola1\" a la \"cola2\" excepto el último elemento luego eliminar el último elemento de la \"cola1\" tambien intercambiar el nombre de \"cola1\" y \"cola2\". Para realizar la operación de \"top\" en la pila se va a mover todos los elementos de la \"cola1\" a la \"cola2\" excepto el último elemento seguido de eso obtener el último elemento de la \"cola1\" e intercambiar el nombre de \"cola1\" y \"cola2\" Para verificar si la pila está vacía: La pila estará vacía si ambas colas están vacías."
],[
    "BECERRA SAA",
    "SAMIRA BELEN",
    "samira.becerra.s@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  08:13",
    "19 de mayo de 2023  08:43",
    "30 minutos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos con la misma prioridad son procesados en orden aleatorio",
    "Verdadero",
    "El árbol B\/B+ es útil para búsquedas en tiempo constante, ya que todos los nodos tienen el mismo tamaño",
    "Falso",
    "Es útil usar grafos para mantener datos ordenados por claves y realizar búsquedas por prioridad.",
    "Verdadero",
    "Podemos usar un montículo binario para encontrar el k-ésimo elemento más pequeño de una lista: construimos un montículo a partir de la lista original y luego eliminamos los k-1 elementos más pequeños de manera secuencial. El elemento siguiente es el k-ésimo elemento más pequeño",
    "Verdadero",
    "La operación de búsqueda en un árbol B+ implica recorrer todos los nodos hoja del árbol hasta encontrar el valor deseado",
    "Falso",
    "La búsqueda en anchura encuentra la solución óptima para problemas de camino más corto.",
    "Verdadero",
    "A diferencia de los arreglos ordenados, las tablas hash pueden tener un tiempo de acceso constante para la búsqueda de elementos",
    "Verdadero",
    "Insertar n elementos ordenados de menor a mayor en un montículo de mínimos tiene complejidad O(n log n).",
    "Falso",
    "La complejidad temporal de la búsqueda en un árbol B es O(log n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "Considera que tienes un mapa donde la clave es el nombre de una película y el valor es una lista de actores. ¿Cómo implementarías una función para encontrar todas las películas en las que trabaja un actor determinado?",
    "antes de implementar la función le preguntaría al usuario o ingresaría el nombre del actor a buscar, luego de eso implementaría la función en la que se realiza una búsqueda por el mapa y se busca a través de las películas existentes. En cada película se busca el nombre del actor y si es que se encuentra se crea una  una lista en la que se ingresa el nombre de la película en la que aparece tal actor, y luego se va recorriendo por todas las películas y se busca el nombre del actor con los que están en la lista de actores de tal película, si se encuentra se realiza un pushBack para insertar el nombre de la película en la lista de PELÍCULAS QUE HA REALIZADO EL ACTOR",
    "Suponga que tiene un mapa de restaurantes, donde cada restaurante tiene una lista de platos en su menú. ¿Cómo podría imprimir todos los restaurantes que tienen \"pasta carbonara\" en su menú?",
    "(clave-> nombre restaurante, valor->lista con platos del menú)Se realiza una búsqueda a través del mapa, es decir, se recorre cada restaurante y se compara si dentro de la lista del mapa se encuentra el palto de \"pasta carbonara\", además se debe realizar una marca a los restaurantes que ya han sido visitados, si estos tienen el plato buscado se crea una lista con RESTAURANTES CON PASTA CARBONARA y se agrega a esta mediante pushBack y se eliminan del mapa (así sucesivamente con cada restaurante, es decir se visita, si es que existe se agrega a la lista y se elimina). Si el plato no se encuentra en la lista de platos del menú del restaurante, simplemente se marca como visitado y se elimina. ",
    "Cree un algoritmo que, usando una pila, verifique si una secuencia de llaves y corchetes está correctamente anidada. Por ejemplo, \"{[()]}\" y \"{}\" están correctamente anidados, mientras que \"{[(])}\" y \"{[}\" no lo están.",
    "Se ingresa la secuencia de llaves y corchetes a evaluar. La pila la podríamos implementar con un arreglo. \n\nEn esta función, se encontraría el elemento que se encuentra en el top de la pila, este se compara con el último elemento ingresado a la pila, si estos son iguales se continua con la ejecución del código, comprobando sucesivamente el top con el último dato ingresado , si estos son siempre verdaderos, se imprime un mensaje y tenemos que la secuencia ingresada es palíndromo, de lo contrario el booleano retornará falso y se imprime un mensaje en el que se indica que la secuencia no es igual. \n\nTambién, se podría ingresar el primer elemento a una lista y el top de la pila se compara con este si son iguales continuamos, de lo contrario se termina ejecución con mensaje de error. "
],[
    "CHAMORRO ROJAS",
    "LEANDRO BERNABE",
    "leandro.chamorro.r@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:25",
    "19 de mayo de 2023  14:55",
    "30 minutos 1 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos se eliminan en función de su orden de llegada",
    "Falso",
    "El árbol B\/B+ es útil para la implementación de algoritmos de búsqueda en grafos, ya que permite una rápida búsqueda de nodos y aristas",
    "Falso",
    "Un grafo es útil cuando queremos modelar sistemas de control, como los circuitos eléctricos o los sistemas de producción, ya que los grafos permiten representar las conexiones entre los elementos y analizar cómo afecta una perturbación a todo el sistema",
    "Verdadero",
    "Al igual que un montículo, un árbol AVL también se podría implementar usando un arreglo.",
    "Verdadero",
    "En un árbol B, la operación de eliminación puede requerir la fusión de nodos vecinos si un nodo se queda sin suficientes claves",
    "Falso",
    "La búsqueda en profundidad puede ser implementada de manera recursiva.",
    "Verdadero",
    "Los árboles B son ideales para el acceso secuencial de datos",
    "Verdadero",
    "La búsqueda de un elemento en un montículo tiene complejidad O(n)",
    "Verdadero",
    "La complejidad espacial de un árbol B+ es mayor que la de un árbol B debido a que los nodos internos almacenan más claves.",
    "Falso",
    "Imagina que tienes un mapa con las calificaciones de los estudiantes, donde la clave es el nombre del estudiante y el valor es su calificación. ¿Cómo podrías implementar una función para encontrar a todos los estudiantes que aprobaron (calificación mayor a 5)?",
    "Como no se indica se asume que el mapa no esta ordenado. Podría implementar una función que obtenga el primero del mapa y revise su calificación, si es mayor que 5 (como se indica en el enunciado), se guardará en una lista y se va repitiendo el proceso hasta que se acabe el mapa.",
    "Considere que tenemos un mapa de estudiantes, donde cada estudiante tiene una lista de asignaturas. Cada asignatura tiene una lista de calificaciones. ¿Cómo podría implementar una función para calcular el promedio general de cada estudiante?",
    "La clave del mapa es el nombre del estudiante. Crearía una funcion que obtenga el primero del mapa y luego realice lo siguiente:\n\n- Se crea una variable prom, esta variable será el promedio, inicializada en 0\n\n- Se recorre la lista de la asignatura y por cada asignatura se suman las notas en una variable sum (esta variable será reseteada a 0 cada vez que se entre a una nueva asignatura) y se dividen en el total de esa asignatura, si no se posee cuanto es el total entonces se va sumando hasta que la lista sea null.\n\n-Luego este total obtenido se suma a la variable prom y se repite con el resto de asignaturas, obteniendo el promedio.\n\nSe repite el proceso con los demás estudiantes",
    "Dado un laberinto representado como una matriz de celdas, describe un algoritmo que encuentre un camino desde la entrada hasta la salida utilizando una pila.",
    "Asumo que el laberinto esta representado como una matriz con de arreglos que se conectan entre si, a no ser de que sea un callejón sin salida.\nEl algoritmo empezaría de la entrada y recorrería el primer callejón (arreglo de una casilla de la matriz) que encuentre hasta el final, al llegar al final se devolvería hasta encontrar una conexión con otro callejón (arreglo) y lo recorrería, esto se repite hasta encontrar una salida.\n\nEn la pila se estaría guardando la posición de la matriz y su arreglo, por ejemplo al empezar se guarda la posición de la matriz en el inicio, luego se mete la posicion del arreglo y se guarda hasta llegar al final, luego se van removiendo hasta encontrar un callejon y se repite"
],[
    "ANABALON NAVARRETE",
    "CESAR CRISTOBAL",
    "cesaranabalon900@gmail.com",
    "Finalizado",
    "19 de mayo de 2023  08:12",
    "19 de mayo de 2023  08:23",
    "11 minutos 3 segundos",
    "Sin calificar aún",
    "Se puede usar colas con prioridad para almacenar los nodos en un algoritmo de búsqueda en grafos",
    "Falso",
    "En un árbol B, se puede tener más de un valor asociado a una misma clave",
    "Falso",
    "Se puede usar grafos para modelar sistemas de recomendación, como en aplicaciones de comercio electrónico o de películas, ya que los grafos pueden representar las preferencias de los usuarios y las relaciones entre productos o películas",
    "Verdadero",
    "En un montículo binario, todos los niveles del árbol excepto posiblemente el último están completamente llenos, y los nodos del último nivel se llenan de izquierda a derecha",
    "Verdadero",
    "Para eliminar un dato en un árbol B, basta con buscar la clave y eliminarla del nodo correspondiente. Si el nodo se queda sin claves, debemos realizar una fusión.",
    "Verdadero",
    "La búsqueda en anchura encuentra la solución óptima para problemas de camino más corto.",
    "Verdadero",
    "A diferencia de las tablas hash, los árboles binarios no tienen un orden definido para los elementos almacenados",
    "Falso",
    "Insertar n elementos ordenados de menor a mayor en un montículo de mínimos tiene complejidad O(n log n).",
    "Verdadero",
    "La búsqueda en un árbol B tiene complejidad temporal O(n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "¿Cómo podríamos implementar una función que tome una lista de palabras y retorne las palabras ordenadas de acuerdo a su longitud? (use TDAs y no algoritmos de ordenamiento)",
    "con un mapa y según la prioridad que tenga estará mas arriba o mas abajo con esto contamos la longitud de la palabra y la almacenamos con un índice mayor o menor ",
    "Considere un mapa de pacientes en un hospital, donde cada paciente tiene una lista de medicamentos que están tomando. ¿Cómo podría implementar una función para encontrar todos los pacientes que están tomando un medicamento específico?",
    "se puede hacer dirección de mapa, en donde se agregan los pacientes a una lista que ocupan estos medicamentos",
    "Explique cómo podría implementar una cola con prioridad, usando 2 pilas. ¿Como realizaría inserciones y eliminaciones en la cola con prioridad?",
    "para la inserción utilizaría la primera pila y para eliminar se crearía una copia de la primera, buscando el dato que se quiera eliminar\n\n}"
],[
    "MIRANDA VASQUEZ",
    "DANIEL IGNACIO",
    "daniel3318bl@gmail.com",
    "Finalizado",
    "18 de mayo de 2023  12:46",
    "18 de mayo de 2023  13:11",
    "25 minutos 20 segundos",
    "Sin calificar aún",
    "Es recomendable usar colas con prioridad cuando todos los elementos tienen la misma prioridad",
    "Falso",
    "El árbol B\/B+ es útil para el almacenamiento y recuperación eficiente de grandes cantidades de datos en disco, ya que minimiza las operaciones de lectura\/escritura y reduce el tiempo de acceso a los datos",
    "Verdadero",
    "Se puede usar grafos para analizar redes complejas, como la propagación de enfermedades o la interconexión de sistemas informáticos, ya que los grafos permiten modelar las interacciones entre los elementos y estudiar cómo se propagan los efectos a través de la red",
    "Verdadero",
    "En un montículo binario, todos los niveles del árbol excepto posiblemente el último están completamente llenos, y los nodos del último nivel se llenan de izquierda a derecha",
    "Falso",
    "La operación de búsqueda en un árbol B+ implica recorrer todos los nodos hoja del árbol hasta encontrar el valor deseado",
    "Verdadero",
    "La búsqueda en anchura utiliza una cola para almacenar los nodos a visitar.",
    "Verdadero",
    "Los arreglos son más eficientes que las listas enlazadas para acceder al i-ésimo elemento",
    "Verdadero",
    "El acceso al elemento mínimo en un montículo binario de mínimos tiene complejidad temporal O(log n) ya que se debe atravesar el árbol",
    "Falso",
    "La complejidad temporal de la inserción en un árbol B es O(1)",
    "Falso",
    "Suponga que tiene un conjunto de operaciones a realizar, cada una con un tiempo de duración diferente. ¿Cómo podría usar una cola de prioridad para ordenar las operaciones de manera que se realicen primero las más cortas?",
    "Con un montículo binario de mínimos , al definir la operación de inserción correctamente en el montículo, tiene que pasar que los elementos con menor duración en este caso, se guarden en la raíz luego de una serie de pasos. Así al insertar una operación, tiene que ir almacenándose en nuestro montículo de menor a mayor.",
    "Suponga que tiene un mapa de restaurantes, donde cada restaurante tiene una lista de platos en su menú. ¿Cómo podría imprimir todos los restaurantes que tienen \"pasta carbonara\" en su menú?",
    "Con un mapa de platos, cada nodo del mapa tendría el nombre del plato y una lista de restaurantes que tienen a ese plato en su menú.\n\nCada vez que se agrega un plato en el mapa de restaurantes, también se debe ingresar al mapa de platos y almacenar al restaurante en su lista. Así tendremos de manera eficiente listas de restaurantes que contienen a un plato específico. Luego recorremos el mapa de platos y por cada nodo, su lista, e imprimimos.",
    "Explica un algoritmo para implementar una cola utilizando dos pilas.",
    "Tendría una pila que su primer elemento apunte al primero de la otra pila, así cuando quiero eliminar en mi nueva cola, retiro el top de la primera pila, y para insertar, agrego en el top de la segunda.\n\nA->B->C->D (primera pila) (A ES EL TOP)\n\nD->E->F->G (primera pila) (G ES EL TOP)\n\nCOLA: A->B->C->D->E->F->G "
],[
    "CEPEDA DONOSO",
    "DANIEL ALEXANDER",
    "soslal307@hotmail.com",
    "Finalizado",
    "18 de mayo de 2023  12:58",
    "18 de mayo de 2023  13:27",
    "29 minutos 48 segundos",
    "Sin calificar aún",
    "Las colas con prioridad son útiles para procesar tareas en orden de importancia",
    "Verdadero",
    "Los árboles B son similares a los árboles AVL en términos de estructura",
    "Falso",
    "Se puede usar grafos para analizar redes complejas, como la propagación de enfermedades o la interconexión de sistemas informáticos, ya que los grafos permiten modelar las interacciones entre los elementos y estudiar cómo se propagan los efectos a través de la red",
    "Verdadero",
    "En un montículo binario de máximos, el elemento de mayor valor siempre se encuentra en la raíz del árbol, por lo que la eliminación de este elemento implica reorganizar el árbol para mantener la propiedad de ordenación.",
    "Verdadero",
    "En un árbol B, cada nivel del árbol se llena por completo antes de agregar un nuevo nivel",
    "Verdadero",
    "La búsqueda en profundidad es más eficiente que la búsqueda en anchura en grafos profundos.",
    "Verdadero",
    "Las tablas hash son más eficientes que los arreglos y las listas enlazadas para buscar elementos en la estructura",
    "Verdadero",
    "El orden en que se ingresan los elementos en un montículo binario no afecta su complejidad temporal, ya que siempre se cumple la propiedad del montículo",
    "Verdadero",
    "La inserción en un árbol B+ tiene complejidad temporal O(log n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "Imagina que tienes un mapa con las calificaciones de los estudiantes, donde la clave es el nombre del estudiante y el valor es su calificación. ¿Cómo podrías implementar una función para encontrar a todos los estudiantes que aprobaron (calificación mayor a 5)?",
    "Crearía una lista con el nombre de todos los estudiantes. Se recorre esta lista y se copia el nombre de cada estudiante uno por uno a una variable que se usará como clave para acceder a su calificación. Si esta es mayor a 5 se copia la variable con el nombre a un nuevo nodo que se ingresa a una segunda lista. Se repite este proceso para todos los estudiantes de la primera lista. Esta segunda lista solo tendría estudiantes con una calificación mayor a 5.",
    "Considere un mapa de pacientes en un hospital, donde cada paciente tiene una lista de medicamentos que están tomando. ¿Cómo podría implementar una función para encontrar todos los pacientes que están tomando un medicamento específico?",
    "La función tendría una lista con el nombre de todos los pacientes y una variable con el nombre del medicamento especifico. Se recorre la lista desde el inicio y se usa el nombre del paciente como clave en el mapa para acceder a la lista que contiene los medicamentos de un paciente. Esta se recorre y se van comparando todos los elementos de esta lista con la variable nombre del medicamento especificado. Si en algún momento son iguales se deja de recorrer y se almacena el nodo de la primera lista que contenía el nombre del paciente a una nueva lista. Esta lista solo tendría los nombres de los pacientes que tomen el medicamento especifico.  ",
    "Describe el algoritmo de búsqueda en anchura (BFS, por sus siglas en inglés) en un grafo, utilizando una cola.",
    "La búsqueda por anchura analiza el grafo nivel por nivel. Se comienza por los niveles más cercanos a la raíz y luego se va descendiendo. Cada estado se agrega a una cola, para analizar si son validos por orden de llegada. Si no hay estados validos en un nivel se desciende al siguiente hasta encontrarlo. "
],[
    "CARVAJAL MUÑOZ",
    "RUBEN ANTONIO",
    "ruben.carmun@gmail.com",
    "Finalizado",
    "19 de mayo de 2023  14:37",
    "19 de mayo de 2023  15:06",
    "29 minutos 31 segundos",
    "Sin calificar aún",
    "Las colas con prioridad pueden ser implementadas utilizando diferentes estructuras de datos, como montículos o listas enlazadas",
    "Verdadero",
    "El árbol B\/B+ permite reducir el espacio de almacenamiento en disco, ya que los nodos del árbol son más pequeños que los de otros árboles",
    "Verdadero",
    "Se puede usar grafos para modelar sistemas de recomendación, como en aplicaciones de comercio electrónico o de películas, ya que los grafos pueden representar las preferencias de los usuarios y las relaciones entre productos o películas",
    "Verdadero",
    "Un montículo binario solo puede ser utilizado para elementos de tipo numérico, ya que la propiedad de ordenación se basa en la comparación de valores numéricos",
    "Falso",
    "La operación de búsqueda en un árbol B+ implica recorrer todos los nodos hoja del árbol hasta encontrar el valor deseado",
    "Verdadero",
    "La búsqueda en profundidad puede ser implementada de manera recursiva.",
    "Verdadero",
    "A diferencia de la tabla hash, los árboles B+ pueden trabajar con grandes volúmenes de datos.",
    "Verdadero",
    "El acceso al elemento mínimo en un montículo binario de máximos tiene complejidad O(log n), ya que se debe descender por el árbol hasta llegar al nodo hoja más a la izquierda",
    "Verdadero",
    "La búsqueda en un árbol B tiene complejidad temporal O(n), donde n es el número de elementos en el árbol.",
    "Falso",
    "Imagina que tienes un mapa con las calificaciones de los estudiantes, donde la clave es el nombre del estudiante y el valor es su calificación. ¿Cómo podrías implementar una función para encontrar a todos los estudiantes que aprobaron (calificación mayor a 5)?",
    "cro una funcion que haga de operacion lo siguiente:\n\n- hago un for que recorrerá cada casilla o bucket de un mapa que contenga la clave nombre y su valor de calificacion\n\n-dentro de el for llamo a un if que comparara si el valor dentro de la casilla (representando un estudiante) es mayor o no y dependiendo de el resultado se le agregara a una lista que incluirá los datos de el estudiante que tengan calificacion mayor que 5\n\n- luego se hara print recorriendo la lista que contiene a todos los estudiantes aprobados",
    "Tenemos un mapa de artistas. Cada artista, además del nombre, tiene una lista de géneros musicales asociados (rock, pop, jazz, clásico, etc.) ¿Cómo podríamos imprimir el número de artistas asociados a cada género, indicando el género más popular?",
    "creo una funcion que haga lo siguiente\n\n-creo un mapa que incluira todos los generos musicales y en cada genero musical(que seran los keys) contendra como valor contador que representara las veces que ha aparecido inicialiisandolo en 0\n\n-recorreré todas las casillas de el mapa que contiene artistas y en cada casilla recorreré su respectiva lista de géneros musicales asociados y hare un searchmap en el mapa genero musical y aumentare su respectivo contador de el genero respectivo\n\n-después de haber terminado con el proceso anterior recorreré el mapa de géneros musicales y almacenare un máximo que ira comparándose con todos los otros géneros y en el proceso reemplazando el valor aplicando criterio para que la variable máxima termine almacenando el genero musical con mayor conteo, el genero musical con mayor conteo representaran el genero mas popular, y bastara con recorrer las casillas de los mapas de genero para hacer print a sus respectivos conteos que darán a entender el numero de artistas asociados a este genero.",
    "Describa un algoritmo para implementar una pila utilizando dos colas.",
    ".inbicializa las 2 colas: cola 1 y cola 2\n\n-para la operacion push se llenara a la cola 1 y si la cola 2 no esta vacia lo insertare a la cola 1 y agregare el nuevo elemento a la \n\ncola 1 simulando una pila\n\n-para eliminacion: se asegura que cola 1 tenga elementos,  se moveran todos los elementos a la cola 2 excepto el ultimo y despues de esto se intercambiaran los nombres ahora cola 1 representando la cola 2 y viceversa\n\n- la pila estara vacia si ambas colas estan vacias"
],[
    "TORO MUNDACA",
    "RICARDO BASTIAN",
    "ricardo.toro.m@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:47",
    "19 de mayo de 2023  14:55",
    "8 minutos 5 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos se eliminan en función de su orden de llegada",
    "Falso",
    "El árbol B\/B+ es útil para la gestión de archivos, ya que permite una rápida recuperación y ordenamiento de los registros",
    "Falso",
    "Se puede usar grafos para modelar relaciones y conexiones entre elementos, como redes de transporte o redes sociales, ya que los grafos permiten representar de manera clara y visual la estructura de estas conexiones y facilitan el análisis y la toma de decisiones",
    "Verdadero",
    "En un montículo binario, la búsqueda de un elemento se realiza en tiempo constante",
    "Falso",
    "En un árbol B+, los datos están organizados en orden ascendente en cada hoja y las hojas están enlazadas",
    "Verdadero",
    "La búsqueda en anchura es una buena opción para grafos con una profundidad desconocida.",
    "Verdadero",
    "A diferencia de los montículos, los arreglos ordenados mantienen la posición relativa de los elementos",
    "Falso",
    "El acceso al elemento mínimo en un montículo binario de mínimos tiene complejidad temporal O(1), ya que este se encuentra en la raíz del árbol",
    "Verdadero",
    "La inserción en un árbol B+ tiene complejidad temporal O(log n), donde n es el número de elementos en el árbol.",
    "Falso",
    "Imagina que tienes un mapa con las calificaciones de los estudiantes, donde la clave es el nombre del estudiante y el valor es su calificación. ¿Cómo podrías implementar una función para encontrar a todos los estudiantes que aprobaron (calificación mayor a 5)?",
    "Dentro de la fución crearía una lista para ir guardando los datos de los estudiantes que posean una nota mayor a 5, luego recorrería el mapa y buscaría uno a uno e iría guardando los nombres dentro de la lista si su nota es mayor a 5.",
    "Supongamos que tenemos un mapa de estudiantes donde la clave es el ID del estudiante y el valor es una lista de asignaturas en las que se ha inscrito. ¿Cómo implementarías una función para eliminar una asignatura?",
    "La función recibiría el ID del estudiante y la asginatura que desea eliminar, luego accede al mapa con el ID y en la lista se busca la asignatura y luego de posicionarse en la ubicación necesaria, utiliza la función pop para eliminar la asignatura.",
    "Dado un laberinto representado como una matriz de celdas, describe un algoritmo que encuentre un camino desde la entrada hasta la salida utilizando una pila.",
    "-"
],[
    "SILVA REINOSO",
    "PABLO ANDRES",
    "psreinoso5@gmail.com",
    "Finalizado",
    "19 de mayo de 2023  14:48",
    "19 de mayo de 2023  15:16",
    "28 minutos 31 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos con la misma prioridad se procesan en orden de llegada",
    "Verdadero",
    "Los árboles B+ son utilizados para mejorar el rendimiento de la búsqueda secuencial en disco",
    "Verdadero",
    "Se puede usar grafos para modelar redes de transporte, como el tráfico de carreteras o el transporte aéreo, ya que los grafos permiten representar la estructura de las conexiones y las relaciones entre ellas",
    "Verdadero",
    "Un montículo binario es una estructura de datos eficiente para ordenar grandes cantidades de datos en memoria RAM",
    "Falso",
    "La operación de búsqueda en un árbol B+ implica recorrer todos los nodos hoja del árbol hasta encontrar el valor deseado",
    "Falso",
    "La búsqueda en anchura utiliza una cola para almacenar los nodos a visitar.",
    "Verdadero",
    "Los árboles B son ideales para el acceso secuencial de datos",
    "Falso",
    "El acceso al elemento mínimo en un montículo binario de mínimos tiene complejidad temporal O(1), ya que este se encuentra en la raíz del árbol",
    "Verdadero",
    "La complejidad espacial de un árbol B+ es mayor que la de un árbol B debido a que los nodos internos almacenan más claves.",
    "Verdadero",
    "Describa cómo se puede utilizar un conjunto o mapa para verificar si una lista tiene elementos duplicados.",
    "dentro del mapa se pueden guardar los elementos de la lista utilizando una clave para cada elemento. Antes de guardas los elementos en el mapa hará una busqueda para ver si el elemento se encuentra dentro del mapa. Si no encuentra el elemento, se agregará en el mapa, en caso contrario se imprimira que el elemento esta repetido en la lista.",
    "Supongamos que tenemos un mapa de estudiantes donde la clave es el ID del estudiante y el valor es una lista de asignaturas en las que se ha inscrito. ¿Cómo implementarías una función para eliminar una asignatura?",
    "Se le pediria al usuario que ingrese el ID del estudiante, luego se usara un searchmap() para llegar a la lista de asignaturas del estudiante, si no se encuentra registrado el estudiante se avisará. Después se pedirá que ingrese el nombre de la asignatura a eliminar y se buscara dentro de la lista, si la asignatura está dentro de la lista se sacará, en caso contrario se avisará al usuario que la asignatura no pertenece al estudiante.",
    "Explique un algoritmo que permita calcular la profundidad de un árbol binario utilizando una pila. La profundidad de un árbol binario es la longitud del camino más largo desde la raíz hasta una hoja.",
    "Primero guardamos los elementos del árbol binario en la pila. Después creamos las variable padre, hijo mayor e hijo menor. luego obtenemos un elemento de la pila y verificamos si el padre esta ocupado o no en caso que el padre no este ocupado, lo guardamos en la variable padre, caso contrario comparamos si es mayor o menor que el padre y la disponibilidad de las variables hijo mayor o menor cuando corresponda. Si hijo mayor o menor están vacíos se guarda en el que corresponda, en caso contrario el hijo mayor o menor toma la posición del padre y ambos hijos quedaran como nulos, para luego comparar el elemento con el nuevo padre y agregarlo en hijo mayor o menor donde corresponda. cada vez que se haga un cambio a la variable padre se aumentara en 1 un contador llamado rango. cuando no queden elementos de la pila se imprimirá el valor de la variable rango."
],[
    "SILVA CASTRO",
    "FRANCISCA JAVIERA",
    "francisca.silva.c@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  08:12",
    "19 de mayo de 2023  08:42",
    "29 minutos 29 segundos",
    "Sin calificar aún",
    "Se puede utilizar colas con prioridad para reducir el tiempo de espera promedio de los clientes de un servicio",
    "Verdadero",
    "Los árboles B+ son una variante de los árboles B, donde los nodos hoja contienen registros de datos",
    "Verdadero",
    "Se puede usar grafos para analizar redes complejas, como la propagación de enfermedades o la interconexión de sistemas informáticos, ya que los grafos permiten modelar las interacciones entre los elementos y estudiar cómo se propagan los efectos a través de la red",
    "Verdadero",
    "En un montículo binario de máximos, el elemento de mayor valor siempre se encuentra en la raíz del árbol, por lo que la eliminación de este elemento implica reorganizar el árbol para mantener la propiedad de ordenación.",
    "Verdadero",
    "En un árbol B, la operación de búsqueda tiene una complejidad de tiempo constante, independientemente del número de elementos almacenados en el árbol",
    "Falso",
    "La búsqueda en anchura encuentra la solución óptima para problemas de camino más corto.",
    "Verdadero",
    "Las tablas hash son más eficientes que los arreglos y las listas enlazadas para buscar elementos en la estructura",
    "Verdadero",
    "Insertar n elementos ordenados de menor a mayor en un montículo de mínimos tiene complejidad O(n log n).",
    "Falso",
    "Un árbol B+ tiene una altura de entre 2 y 5 niveles.",
    "Falso",
    "Tenemos una lista de productos con su precio y categoría. ¿Cómo podríamos calcular el precio promedio por categoría usando un mapa?",
    "En el mapa se pueden insertar los elementos de la lista como una colección de pares siendo la clave la categoría y el valor una lista de los productos con sus precios. Para calcular el precio promedio por categoría, se recorre la lista de productos realizando una sumatoria del total de productos y una sumatoria con el precio de cada producto, luego ese total se divide en la cantidad total de productos de esa categoría, después de obtener el precio promedio, este valor se almacena en una nueva lista. ",
    "Considere un mapa de pacientes en un hospital, donde cada paciente tiene una lista de medicamentos que están tomando. ¿Cómo podría implementar una función para encontrar todos los pacientes que están tomando un medicamento específico?",
    "Para encontrar a todos los pacientes que estén tomando un medicamento en especifico, se debe hacer una búsqueda en el mapa visitando a cada paciente, recorrer su lista de medicamentos y comparar si el nombre del medicamento en especifico se encuentra en su lista. De ser así, el nombre del paciente se guarda en una nueva lista y se continua con la búsqueda con el paciente siguiente. Y si el medicamento no se encuentra en su lista, se continua con la búsqueda. ",
    "Explica un algoritmo para implementar una cola utilizando dos pilas.",
    "Ejemplo: pacientes en sala de espera\n\nPara implementar una cola utilizando dos pilas, primero ambas pilas se inicializan vacías, una pila será para pacientes con menos urgencia y la otra para los que tengan un grado de urgencia mayor. Los pacientes se ingresan en la cola y luego se elimina un paciente de la cola (el primero en ingresar), se evalúa su grado de urgencia y se inserta en la pila correspondiente. A medida que los pacientes sean llamados, se van eliminando de la pila en la cual se encontraban para así hacer menos duradera la lista de espera."
],[
    "CABELLO VASQUEZ",
    "CLAUDIO IGNACIO",
    "claudio.cabello.v@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  08:12",
    "19 de mayo de 2023  08:35",
    "23 minutos 20 segundos",
    "Sin calificar aún",
    "Es recomendable usar colas con prioridad cuando todos los elementos tienen la misma prioridad",
    "Falso",
    "El árbol B\/B+ es útil para la implementación de estructuras de datos en memoria principal, ya que minimiza el uso de memoria",
    "Falso",
    "Es útil usar grafos para mantener datos ordenados por claves y realizar búsquedas por prioridad.",
    "Falso",
    "En un montículo binario, todos los niveles del árbol excepto posiblemente el último están completamente llenos, y los nodos del último nivel se llenan de izquierda a derecha",
    "Verdadero",
    "En un árbol B, la operación de eliminación siempre implica la reorganización completa del árbol",
    "Falso",
    "La búsqueda en anchura utiliza una cola para almacenar los nodos a visitar.",
    "Falso",
    "Los arreglos son más eficientes que las listas enlazadas para acceder al i-ésimo elemento",
    "Verdadero",
    "El acceso al elemento mínimo en un montículo binario de máximos tiene complejidad O(log n), ya que se debe descender por el árbol hasta llegar al nodo hoja más a la izquierda",
    "Verdadero",
    "La complejidad espacial de un árbol B+ es mayor que la de un árbol B debido a que los nodos internos almacenan más claves.",
    "Falso",
    "Considere un conjunto de estudiantes con sus respectivas calificaciones. ¿Cómo podría usar una cola de prioridad para identificar rápidamente a los 5 estudiantes con las calificaciones más altas?",
    "En ese caso habría que recorrer los estudiantes y ver sus calificaciones en las materia, de estas se sacan un promedio e implementando una cola con prioridad con montículo de máximos se tiene al con mayor calificación en la raíz, siendo el alumnos que tiene mayor promedio de los primeros. De esta manera se obtienen los alumnos con 5 mejores calificaciones, siendo el alumno que esta en el nodo raíz el que tiene el mayor promedio y al momento de eliminar termina siendo el segundo en la raíz y así sucesivamente hasta el quinto. Por ultimo la prioridad es el promedio.",
    "Suponga que tiene un mapa de restaurantes, donde cada restaurante tiene una lista de platos en su menú. ¿Cómo podría imprimir todos los restaurantes que tienen \"pasta carbonara\" en su menú?",
    "Se recorre el mapa visitando todos los restaurantes y en el valor de cada restaurante se recorre la lista de platos que tiene, al momento de recorrer se realiza una comparación con el nombre del plato, si su plato es \"pasta carbonara\" y si es así se imprime el nombre del restaurant y se detiene la búsqueda en sus demas platos ya que este se encontro, sino sigue buscando y si no se encuentra no se imprime el restaurant. Luego con los demás restaurantes hasta llegar al ultimo. Suponiendo que la clave en el mapa es el nombre del restaurant y que tiene como valor una lista de platos en su menú. Para recorrer el mapa se podria implementar con la funcion first y next y para buscar el plato en la lista se podria hacer con la funcion searchList.",
    "Considere que tenemos un mapa de tareas, en donde cada tarea tiene una lista de tareas precedentes. Describa un algoritmo que imprima las tareas en un orden en que puedan realizarse (tomando en cuenta relación de precedencia).",
    "Suponiendo que es un mapa no ordenado y que la clave es el nombre de la tarea, habría que recorrer todos los elementos del mapa y con una variable almacenar la tarea con menor prioridad, luego se vuelve a recorrer buscando la tarea con esa prioridad, se imprimen los prescendentes y luego la tarea. Ademas la tarea es señalada como que ya fue marcada, para no volverla a mostrar. Otra posible solucion seria recorrer el mapa no ordenado y en una tda creada arrayList almacenar las prioridades que se encuentran en el mapa y ordenarlas por prioridad (de menor a mayor) de esta manera al buscar ya sabemos el orden de prioridades y si se encuentra una tarea en el mapa con esa prioridad se imprimen los prescendentes recorriendolos y luego la tarea, ademas al momento de mostrar una tarea se marca que ya fue mostrada. Este algoritmo es considerando que cada tarea tiene una prioridad y una lista de tareas prescendentes. Si no se encuentra la prioridad solo habria que recorrer el mapa e imprimir todas las tareas prescedentes, marcarlas y asi con las demas, si no esta marcada como que fue mostrada esta se mostrara."
],[
    "BUSTAMANTE FOSSA",
    "MAXIMILIANO ANDRES",
    "maximiliano.bustamante.f@mail.pucv.cl",
    "Finalizado",
    "18 de mayo de 2023  12:46",
    "18 de mayo de 2023  13:01",
    "14 minutos 36 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, la prioridad de un elemento se determina por un valor asociado a dicho elemento",
    "Verdadero",
    "Los árboles B pueden ser utilizados para implementar índices en bases de datos",
    "Verdadero",
    "Un grafo es útil cuando queremos analizar patrones de tráfico en internet, ya que los grafos pueden representar los flujos de datos entre diferentes sistemas y los nodos críticos en la red",
    "Verdadero",
    "Un montículo binario es una estructura de datos que permite mantener una colección de elementos ordenados en función de su valor, con una complejidad de tiempo logarítmica para las operaciones de inserción, eliminación y búsqueda",
    "Falso",
    "En un árbol B, los nodos pueden tener más de dos hijos",
    "Verdadero",
    "La búsqueda en anchura es una buena opción para grafos con una profundidad desconocida.",
    "Verdadero",
    "Los árboles B son ideales para el acceso secuencial de datos",
    "Verdadero",
    "Insertar n elementos ordenados de menor a mayor en un montículo de mínimos tiene complejidad O(n log n).",
    "Falso",
    "La complejidad temporal de la inserción en un árbol B es O(1)",
    "Verdadero",
    "Considera que tienes un mapa donde la clave es el nombre de una película y el valor es una lista de actores. ¿Cómo implementarías una función para encontrar todas las películas en las que trabaja un actor determinado?",
    "guardaría las películas en tablas hash con el nombre clave y teniendo dentro la lista de los actores que participan en cada una de estas. Después recorrería buscando película por película, recorriendo estas y si el actor buscado es encontrado en la película, el nombre de la película en el que se encontró el actor seria agregada a otra lista donde después de recorrer todos las películas se retornaría finalmente la lista con las películas en el cual el actor actuó.",
    "Considere que tenemos un mapa de estudiantes, donde cada estudiante tiene una lista de cursos y las notas obtenidas en cada curso. ¿Cómo podría implementar una función para encontrar el curso en el que los estudiantes tienen el promedio de notas más bajo?",
    "implementaria un puntero el cual corresponderia a un arreglo en el que estaria cada curso y otro a la cantidad de estudiantes recorridos, recorreria el mapa de estudiantes y en cada curso mandaria el puntero del arreglo del curso y el puntero de estudiantes recorrido, en este calcularia el promedio del estudiante en el curso y lo dividiria por la cantidad de estudiantes hasta ahora, eso lo repetiria estudiante por estudiante y curso por curso, donde finalmente compararia los elementos del arreglo y retornaria el que tenga el promedio más bajo.",
    "Explique cómo podría implementar una cola con prioridad, usando 2 pilas. ¿Como realizaría inserciones y eliminaciones en la cola con prioridad?",
    "Para implementar una cola de prioridad utilizando dos pilas, una pila se utilizaría para almacenar los elementos con una prioridad más alta, mientras que la otra pila se utilizaría para almacenar los elementos con prioridad más baja. La pila superior de la pila de prioridad más alta contendría el siguiente elemento a retirar, mientras que la pila superior de la pila de prioridad más baja contendría el elemento más reciente que se agregó."
],[
    "FERNANDEZ VERA",
    "RODOLFO ANTONIO",
    "rodolfo.fernandez.v@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:25",
    "19 de mayo de 2023  14:54",
    "29 minutos 18 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos con la misma prioridad son procesados en orden aleatorio",
    "Falso",
    "El árbol B\/B+ es útil para la gestión de archivos, ya que permite una rápida recuperación y ordenamiento de los registros",
    "Verdadero",
    "Un grafo es útil cuando queremos modelar sistemas de control, como los circuitos eléctricos o los sistemas de producción, ya que los grafos permiten representar las conexiones entre los elementos y analizar cómo afecta una perturbación a todo el sistema",
    "Verdadero",
    "Un montículo binario solo puede ser utilizado para elementos de tipo numérico, ya que la propiedad de ordenación se basa en la comparación de valores numéricos",
    "Falso",
    "En un árbol B+, los nodos internos pueden contener datos además de las claves",
    "Falso",
    "La búsqueda en profundidad utiliza una cola para almacenar los nodos a visitar.",
    "Falso",
    "Los arreglos ordenados son más eficientes que las listas enlazadas para buscar elementos en la estructura",
    "Falso",
    "El acceso al elemento mínimo en un montículo binario de mínimos tiene complejidad temporal O(log n) ya que se debe atravesar el árbol",
    "Falso",
    "La complejidad temporal de la inserción en un árbol B es O(1)",
    "Falso",
    "¿Cómo implementaría una cola de prioridad para administrar las solicitudes de atención al cliente en un sistema de soporte técnico, donde los clientes VIP tienen la más alta prioridad, seguidos por los clientes habituales y luego los nuevos clientes?",
    "Implementamos una cola de máximos, donde primero asignamos a cada cliente, según si son vip o no, su prioridad, por ejemplo 3. Luego los clientes habituales su prioridad correspondiendentes, como 2, y finalizamos con los nuevos clientes con prioridad 1. (Asumimos que cada cliente segun su reputacion, mantienen la misma prioridad que sus pares, almacenando los que poseen misma prioridad por orden de llegada) Al momento de administrar la atención, simplemente vamos sacando el top de la cola y listo.",
    "Tenemos un mapa de empleados, cada uno con una lista de proyectos en los que han trabajado y el tiempo que dedicaron a cada uno. ¿Cómo podría implementar una función para encontrar el empleado que ha dedicado más tiempo a los proyectos?",
    "Asumiendo que la clave del mapa serian los nombres de los empleados, recorremos el mapa mediante un while y usando nextMap, luego creamos una variable que cree un promedio del tiempo que ha dedicado los proyectos y otra variable que vaya guardando el empleado con mayor promedio (va comparando por cada iteracion), comenzamos a analizar la lista de cada proyecto y la vamos recorriendo, guardando el tiempo que este dedico a \"x\" proyecto, finalmente terminamos de recorrer y nos entrega el empleado con mayor tiempo dedicado a los proyectos. ",
    "Explique cómo podría implementar una cola con prioridad, usando 2 pilas. ¿Como realizaría inserciones y eliminaciones en la cola con prioridad?",
    "Primero, creamos 2 pilas, una correspondiente a la pila de entrada, y luego una pila de salida.\n\nLuego para ingresar el primer elemento, lo agregamos a la pila de entrada."
],[
    "GATICA LEIVA",
    "SEBASTIAN FELIPE",
    "sebastian.gatica.l@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  08:25",
    "19 de mayo de 2023  08:40",
    "14 minutos 43 segundos",
    "Sin calificar aún",
    "Se puede usar colas con prioridad para almacenar los nodos en un algoritmo de búsqueda en grafos",
    "Verdadero",
    "Los árboles B+ son una variante de los árboles B, donde los nodos hoja contienen registros de datos",
    "Verdadero",
    "Se puede usar grafos para analizar redes complejas, como la propagación de enfermedades o la interconexión de sistemas informáticos, ya que los grafos permiten modelar las interacciones entre los elementos y estudiar cómo se propagan los efectos a través de la red",
    "Verdadero",
    "Un montículo binario solo puede ser utilizado para elementos de tipo numérico, ya que la propiedad de ordenación se basa en la comparación de valores numéricos",
    "Falso",
    "La operación de búsqueda en un árbol B+ implica recorrer todos los nodos hoja del árbol hasta encontrar el valor deseado",
    "Falso",
    "La búsqueda en profundidad utiliza una cola para almacenar los nodos a visitar.",
    "Verdadero",
    "Los arreglos son más eficientes que las listas enlazadas para acceder al i-ésimo elemento",
    "Verdadero",
    "Insertar n elementos ordenados de menor a mayor en un montículo de mínimos tiene complejidad O(n log n).",
    "Falso",
    "La complejidad temporal de la búsqueda en un árbol B es O(log n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "Describa cómo se puede utilizar un conjunto o mapa para verificar si una lista tiene elementos duplicados.",
    "Implementando el mapa, podría ser pasar los datos de la lista al mapa, se generan las respectivas claves de estas, para así compararlas con las del resto, así sabiendo cuantos datos están repetidos.",
    "Tenemos un mapa de empleados, cada uno con una lista de proyectos en los que han trabajado y el tiempo que dedicaron a cada uno. ¿Cómo podría implementar una función para encontrar el empleado que ha dedicado más tiempo a los proyectos?",
    "El nombre del empleado es la clave, al acceder a sus datos tendremos la cantidad de proyectos y cuanto tiempo a dedicado, podríamos guardar el tiempo en una variable y cunado se acceda a otro empleado, esta variable se compara con el tempo invertido del otro empleado, si ese tiempo es más alto, se va cambiando el empleado de puesto por tiempo.",
    "Describe un algoritmo de Breadth-First Search (BFS) para encontrar el camino más corto entre un nodo A y un nodo B (la distancia entre par de nodos conectados es 1).",
    "Para encontrar el camino mas corto entre un nodo A y B se podría realizar una búsqueda por profundidad en un árbol que es más ancho o en anchura si es más profundo, en esta búsqueda se van contando los nodos que recorre la función, hasta encontrar el nodo solicitado, determinando así cual seria el tipo de búsqueda más eficiente y la distancia más corta."
],[
    "LAYANA SILVA",
    "IGNACIO ANDRES",
    "ignacio.layana.s@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:39",
    "19 de mayo de 2023  14:49",
    "10 minutos 50 segundos",
    "Sin calificar aún",
    "Es recomendable usar colas con prioridad cuando todos los elementos tienen la misma prioridad",
    "Falso",
    "En un árbol B, la altura máxima del árbol depende del número de claves y el orden del árbol (cantidad máxima de nodos por hoja)",
    "Verdadero",
    "Se puede usar grafos para modelar sistemas de recomendación, como en aplicaciones de comercio electrónico o de películas, ya que los grafos pueden representar las preferencias de los usuarios y las relaciones entre productos o películas",
    "Verdadero",
    "Al igual que un montículo, un árbol AVL también se podría implementar usando un arreglo.",
    "Verdadero",
    "En un árbol B, la operación de búsqueda tiene una complejidad de tiempo constante, independientemente del número de elementos almacenados en el árbol",
    "Falso",
    "La búsqueda en anchura encuentra la solución óptima para problemas de camino más corto.",
    "Verdadero",
    "A diferencia de la tabla hash, los árboles B+ pueden trabajar con grandes volúmenes de datos.",
    "Verdadero",
    "El acceso al elemento mínimo en un montículo binario de mínimos tiene complejidad temporal O(log n) ya que se debe atravesar el árbol",
    "Falso",
    "La complejidad temporal de la inserción en un árbol B es O(n) debido a que se deben realizar varias divisiones y fusiones de nodos",
    "Verdadero",
    "Describa cómo se puede utilizar un conjunto o mapa para verificar si una lista tiene elementos duplicados.",
    "Ingresando en el mapa el elemento, pero antes de esto buscando si ya se registro con anterioridad en el mapa, ósea realizaremos un searchMap(elemento)  y si este retorna NULL significaría que aun no se encuentra duplicado, pero si algún momento el searchMap encuentra el elemento significaría que la lista tiene el elemento duplicado.",
    "Tenemos un mapa de productos, donde cada producto tiene una lista de precios de diferentes proveedores. ¿Cómo podría implementar una función para encontrar el proveedor más barato para cada producto?",
    "Recorriendo el mapa crearemos un monticulo por cada producto nuevo que se encuentre en la lista de precios, almacenaremos el precio en un mapa que se ira creando con los productos que se encuentren y se comparara el precio que contiene el producto si ya existe, si no se almacena en el mapa el producto, se comparara el precio con el que tenemos asignado y verificaremos cual de estos es el menor, asi con todos los productos, finalmente tendremos un mapa el cual podemos recorrer con todos los productos existente de los proveedores y con cual proveedor es más barato.",
    "Explique cómo podría implementar una cola con prioridad, usando 2 pilas. ¿Como realizaría inserciones y eliminaciones en la cola con prioridad?",
    "entre las colas almaceno un dato en cada una intercalado, con esto puedo acceder a los dos últimos datos existentes por lo tanto puedo comparar sus prioridades, tendremos en cuenta cual dato es el que tiene mayor prioridad y al momento de almacenar un nuevo dato verificaremos cual es el que tiene mayor prioridad en uno y así almacenamos en el lado contrario a este, con esto tendremos un orden con el cual podemos \"jugar\" y realizar las inserción o eliminación ya que sabremos cual es el ultimo dato mayor de la cola y podemos realizar la inserciones o eliminaciones"
],[
    "CUIBIN SANZANA",
    "GABRIEL LEONARDO",
    "gabriel.cuibin.s@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:51",
    "19 de mayo de 2023  15:21",
    "29 minutos 57 segundos",
    "Sin calificar aún",
    "Las colas con prioridad pueden ser implementadas utilizando diferentes estructuras de datos, como montículos o listas enlazadas",
    "Falso",
    "Los árboles B+ son una variante de los árboles B, donde los nodos hoja contienen registros de datos",
    "Verdadero",
    "Se puede usar grafos para modelar relaciones entre entidades, ya que los grafos permiten representar de forma clara y concisa las relaciones complejas entre elementos",
    "Verdadero",
    "En un montículo binario, la búsqueda de un elemento se realiza en tiempo constante",
    "Falso",
    "La operación de inserción en un árbol B implica dividir un nodo si este ya está lleno y redistribuir las claves y los punteros de manera que el árbol siga cumpliendo con las propiedades del árbol B",
    "Verdadero",
    "La búsqueda en anchura utiliza una cola para almacenar los nodos a visitar.",
    "Verdadero",
    "Las listas enlazadas son más eficientes que los arreglos para insertar o eliminar elementos en posiciones aleatorias de la estructura",
    "Falso",
    "La altura máxima de un montículo binario con n elementos es log₂(n)",
    "Falso",
    "La inserción en un árbol B+ tiene complejidad temporal O(log n), donde n es el número de elementos en el árbol.",
    "Falso",
    "Suponga que tiene un conjunto de operaciones a realizar, cada una con un tiempo de duración diferente. ¿Cómo podría usar una cola de prioridad para ordenar las operaciones de manera que se realicen primero las más cortas?",
    "Inicializamos un cola de prioridad donde el dato sea la tarea y la prioridad sea el tiempo, para esto utilizamos un monticulo que ordene por minimos para que la  operacion con menor duracion de tiempo se almacene como el primero y los de mayor duracion se encuentren al final. \n\nLuego simplemente tendriamos que ir sacando y borrando las operaciones del monticulo, para ir realizandolas en el orden de menor tiempo requerido.",
    "Considere que tenemos un mapa de países, donde cada país tiene una lista de sus ciudades y cada ciudad tiene su población. ¿Cómo podría implementar una función para encontrar el país con la mayor población total?",
    "Podríamos usar una cola con prioridad, donde podemos ir almacenando la población total como una prioridad de forma que la de mayor población se quede al principio de la cola.\n\nPara esto abría que recorrer el mapa países y luego recorrer su lista de países e ir almacenando su valor como el nombre de la ciudad y la prioridad como la población total, para que así como se explico anteriormente, se vayan ordenando las ciudad con mayor población al principio de la cola. Luego de recorrer todo el mapa solo bastaría con mostrar el elemento que se encuentre en la primera posición. ",
    "Describe un algoritmo de Breadth-First Search (BFS) para encontrar el camino más corto entre un nodo A y un nodo B (la distancia entre par de nodos conectados es 1).",
    "Se tendria que tener un mapa que marque los nodos que van siendo recorridos para marcalos como visitados (y asi evitar que se pase de nuevo por el mismo nodo) y otra variable que almacene la distancia total recorrida. \n\nEn el caso que no se llegue al destino y pase por un nodo repetido sin que pueda continuar se avanzando por otro camino posibles, y vamos guardando en una lista todos los caminos que se han realizado hasta encontrar todos los caminos posibles que nos lleven del nodo A al B y ademas los que cumplieron que se llegaran del A al B se iran almacenando en un monticulo para tener la distancia mas c"
],[
    "REYES PIZARRO",
    "MATIAS IGNACIO",
    "matias.reyes.p02@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  08:37",
    "19 de mayo de 2023  08:41",
    "3 minutos 35 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, es posible tener elementos con la misma prioridad pero con diferentes tiempos de llegada",
    "Verdadero",
    "El árbol B\/B+ es útil para la gestión de archivos, ya que permite una rápida recuperación y ordenamiento de los registros",
    "Verdadero",
    "Un grafo es útil cuando queremos encontrar la ruta más corta entre dos nodos, ya que los algoritmos de búsqueda de caminos en grafos son muy eficientes",
    "Falso",
    "Un montículo binario se puede utilizar para implementar una cola de prioridad",
    "Verdadero",
    "Para eliminar un dato en un árbol B, basta con buscar la clave y eliminarla del nodo correspondiente. Si el nodo se queda sin claves, debemos realizar una fusión.",
    "Falso",
    "La búsqueda en profundidad consume más memoria que la búsqueda en anchura en grafos anchos.",
    "Falso",
    "Los árboles B son más eficientes que los arreglos y las listas enlazadas para realizar búsquedas, inserciones y eliminaciones en grandes conjuntos de datos",
    "Verdadero",
    "La altura máxima de un montículo binario con n elementos es log₂(n)",
    "Verdadero",
    "Un árbol B+ tiene una altura de entre 2 y 5 niveles.",
    "Falso",
    "Considera que tienes un mapa donde la clave es el nombre de una película y el valor es una lista de actores. ¿Cómo implementarías una función para encontrar todas las películas en las que trabaja un actor determinado?",
    "La función buscaria el \"nombre\" del actor avanzando a traves del mapa, cuando encontrase su nombre, esta se imprimiria de inmediato",
    "Tenemos un mapa de productos, donde cada producto tiene una lista de precios de diferentes proveedores. ¿Cómo podría implementar una función para encontrar el proveedor más barato para cada producto?",
    "-",
    "Explica un algoritmo para implementar una cola utilizando dos pilas.",
    "-"
],[
    "GUARDA CORTES",
    "ELISEO ANTONIO",
    "eliseoguarda@gmail.com",
    "Finalizado",
    "19 de mayo de 2023  14:44",
    "19 de mayo de 2023  15:05",
    "21 minutos 22 segundos",
    "Sin calificar aún",
    "Se puede usar colas con prioridad para almacenar los nodos en un algoritmo de búsqueda en grafos",
    "Verdadero",
    "Los árboles B+ son utilizados para mejorar el rendimiento de la búsqueda secuencial en disco",
    "Verdadero",
    "Se puede usar grafos para modelar relaciones entre entidades, ya que los grafos permiten representar de forma clara y concisa las relaciones complejas entre elementos",
    "Verdadero",
    "Un montículo binario puede ser implementado utilizando un arreglo.",
    "Verdadero",
    "En un árbol B, la operación de eliminación siempre implica la reorganización completa del árbol",
    "Falso",
    "La búsqueda en anchura utiliza una cola para almacenar los nodos a visitar.",
    "Falso",
    "Las listas enlazadas son más eficientes que los arreglos para insertar o eliminar elementos en posiciones aleatorias de la estructura",
    "Verdadero",
    "La complejidad espacial de un montículo binario es O(n), ya que todos los elementos se almacenan en el árbol",
    "Falso",
    "La inserción en un árbol B+ tiene complejidad temporal O(log n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "Considera que tienes un mapa donde la clave es el nombre de una película y el valor es una lista de actores. ¿Cómo implementarías una función para encontrar todas las películas en las que trabaja un actor determinado?",
    "La función solicitaría ingresar el actor que se quiere encontrar, luego recorrería el mapa completo comparando el nombre en cada lista de actores por película, y si encuentra el nombre entonces la película se añade a una pila. Finalmente para mostrar cuáles son estas películas se recorre la pila imprimiéndolas.",
    "Tenemos un mapa de artistas. Cada artista, además del nombre, tiene una lista de géneros musicales asociados (rock, pop, jazz, clásico, etc.) ¿Cómo podríamos imprimir el número de artistas asociados a cada género, indicando el género más popular?",
    "La función recorrería el mapa completo e ingresaría a la lista de géneros musicales de cada artista, entonces añadiría a un arreglo cada género junto a un valor igual a 1, y si el género ya se encuentra en el arreglo entonces se le va sumando 1 al valor. Finalmente, luego de ordenar el arreglo de mayor a menor veces repetidas, se recorrería el arreglo completo imprimiendo los nombres junto a sus valores, así indicando lo pedido.",
    "Describe un algoritmo de Breadth-First Search (BFS) para encontrar el camino más corto entre un nodo A y un nodo B (la distancia entre par de nodos conectados es 1).",
    "Comienza creando una cola vacía y un conjunto visitado vacío. También necesitarás una estructura de datos para almacenar el camino más corto desde el nodo A hasta cada nodo visitado. Agrega el nodo A a la cola y marca el nodo A como visitado. Mientras la cola no esté vacía, repite los siguientes pasos:\n\na. Extrae el primer nodo de la cola y guárdalo en una variable actual.\n\nb. Si el nodo actual es el nodo B, significa que hemos encontrado el camino más corto. Termina el algoritmo y utiliza la estructura de datos que almacenó los nodos previos para reconstruir el camino desde el nodo A hasta el nodo B.\n\nc. Para cada nodo vecino no visitado del nodo actual, agrega el nodo vecino a la cola, marca el nodo vecino como visitado y actualiza la estructura de datos que almacena los nodos previos, estableciendo el nodo actual como el nodo previo del nodo vecino.\n\nSi el ciclo termina y no se ha encontrado un camino desde el nodo A hasta el nodo B, significa que no existe un camino entre los dos nodos en el grafo."
],[
    "FREDES CORDERO",
    "LUCIANO ANDRES",
    "lucianofredes99@gmail.com",
    "Finalizado",
    "18 de mayo de 2023  12:15",
    "18 de mayo de 2023  12:26",
    "11 minutos 14 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos con la misma prioridad se procesan en orden de llegada",
    "Verdadero",
    "El árbol B\/B+ es útil para la implementación de estructuras de datos en memoria principal, ya que minimiza el uso de memoria",
    "Verdadero",
    "Se puede usar grafos para modelar sistemas de recomendación, como en aplicaciones de comercio electrónico o de películas, ya que los grafos pueden representar las preferencias de los usuarios y las relaciones entre productos o películas",
    "Verdadero",
    "En un montículo binario, todos los niveles del árbol excepto posiblemente el último están completamente llenos, y los nodos del último nivel se llenan de izquierda a derecha",
    "Verdadero",
    "En un árbol B+, las hojas contienen todos los datos almacenados en el árbol, mientras que los nodos internos solo contienen claves para dividir los datos en subárboles",
    "Verdadero",
    "La búsqueda en profundidad puede ser implementada de manera recursiva.",
    "Verdadero",
    "A diferencia de las listas enlazadas, los arreglos tienen acceso aleatorio a sus elementos",
    "Verdadero",
    "La inserción en un montículo tiene complejidad O(log n) en el peor de los casos, ya que debemos asegurarnos de mantener la propiedad del montículo al acomodar los elementos",
    "Verdadero",
    "La búsqueda en un árbol B tiene complejidad temporal O(n), donde n es el número de elementos en el árbol.",
    "Falso",
    "Considera que tienes un mapa donde la clave es el nombre de una película y el valor es una lista de actores. ¿Cómo implementarías una función para encontrar todas las películas en las que trabaja un actor determinado?",
    "Lo que haria es recorrer cada pelicula que se encuentre en el mapa, al ingresar a una nueva pelicula ingreso a su lista de actores y busco si se encuentra el actor deseado, si se encuentra se aumentaria un contador para saber que se encuentra en una pelicula, sin \nsi se quisiera tambien guardar el nombre de la pelicula se podria generar una nueva lista guardando el nombre de la pelicula si se encuentra el actor en ella para finalmente recorrer esta nueva lista imprimiendo su clave",
    "Considere un mapa de pacientes en un hospital, donde cada paciente tiene una lista de medicamentos que están tomando. ¿Cómo podría implementar una función para encontrar todos los pacientes que están tomando un medicamento específico?",
    "En este caso se deberia recorrer todo el mapa de pacientes, ingresando a sus respectivas lista de medicamentos y buscando el medicamento deseado, si el paciente tuviera dicho medicamento en su lista su nombre se guardaria en una nueva lista y se pasaria al siguiente paciente, para finalmente con el mapa completamente recorrido mostrar por pantalla la lista de los pacientes que si toman el medicamento",
    "Describe un algoritmo de Breadth-First Search (BFS) para encontrar el camino más corto entre un nodo A y un nodo B (la distancia entre par de nodos conectados es 1).",
    "Se usaria una cola y un grafo, primero entrariamos por el nodo A y buscariamos sus nodos adyacentes, luego recorreremos todos estos nodos y nuevamente ingresando sus nodos adyacentes a la cola, asi se seguira entrando nodo por nodo hasta que al ingresar los nodos adyacentes se encuentre el valor del nodo B indicando que esa seria la ruta mas rapida para encontrar el nodo buscado."
],[
    "FUENZALIDA VELASQUEZ",
    "JOAQUIN EXEQUIEL",
    "joakitoofuenzalida12@gmail.com",
    "Finalizado",
    "18 de mayo de 2023  12:46",
    "18 de mayo de 2023  13:13",
    "27 minutos 18 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos con la misma prioridad se procesan en orden de llegada",
    "Falso",
    "En un árbol B, la inserción siempre se realiza en las hojas. (Aunque luego es posible que el nuevo dato suba a causa de una división de nodos)",
    "Verdadero",
    "Un grafo es útil cuando queremos modelar sistemas de control, como los circuitos eléctricos o los sistemas de producción, ya que los grafos permiten representar las conexiones entre los elementos y analizar cómo afecta una perturbación a todo el sistema",
    "Verdadero",
    "Un montículo binario puede ser implementado utilizando un arreglo.",
    "Verdadero",
    "En un árbol B, la operación de eliminación puede requerir la fusión de nodos vecinos si un nodo se queda sin suficientes claves",
    "Verdadero",
    "La búsqueda en profundidad es más eficiente que la búsqueda en anchura en grafos profundos.",
    "Verdadero",
    "Las tablas hash son más eficientes que los arreglos y las listas enlazadas para buscar elementos en la estructura",
    "Verdadero",
    "El acceso al elemento mínimo en un montículo binario de mínimos tiene complejidad temporal O(1), ya que este se encuentra en la raíz del árbol",
    "Falso",
    "La complejidad temporal de la inserción en un árbol B es O(1)",
    "Verdadero",
    "Teniendo un mapa de estudiantes donde la clave es el número de matrícula y el valor es la nota final. ¿Cómo podrías calcular la nota promedio de todos los estudiantes?",
    "PARA CALCULAR LA CALIFICACIÓN PROMEDIO DE TODOS LOS ESTUDIANTES EN UN MAPA DE ESTUDIANTES DONDE LA CLAVE ES EL NÚMERO DE MATRÍCULA Y EL VALOR ES LA CALIFICACIÓN FINAL, PUEDE SUMAR TODOS LOS VALORES DEL MAPA Y DIVIDIR POR LA CANTIDAD DE VALORES EN EL MAPA",
    "Supongamos que tenemos un mapa de estudiantes donde la clave es el ID del estudiante y el valor es una lista de asignaturas en las que se ha inscrito. ¿Cómo implementarías una función para eliminar una asignatura?",
    "Para eliminar una asignatura de la lista de asignaturas inscritas de un estudiante en un mapa, puedes crear una función que reciba como parámetros el mapa de estudiantes y el ID del estudiante y la asignatura que se desea eliminar. La función debe buscar al estudiante correspondiente en el mapa eliminar la asignatura de su lista de asignaturas inscritas y actualizar el mapa",
    "Explique un algoritmo que permita calcular la profundidad de un árbol binario utilizando una pila. La profundidad de un árbol binario es la longitud del camino más largo desde la raíz hasta una hoja.",
    "Para calcular la profundidad de un árbol binario utilizando una pila, se puede utilizar el algoritmo de recorrido en profundidad, primero se inicializa una pila y agregamos la raíz del árbol a la pila, luego inicializamos un diccionario para mantener el nivel de cada nodo. Añadimos la raíz con nivel 0. Para luego inicializar una variable \"Profundidad\" en 0.\n\nDespués sacamos el ultimo nodo de pila, si el nodo es una hoja, actualizamos la profundidad si es mayor que el valor actúa, si no es una hoja, agregamos sus hijos a la pila, y agregamos los niveles de los hijos al diccionario.\n\ny por ultimo retornamos la variable profundidad."
],[
    "ARAVENA PEREZ",
    "ALEX RODRIGO",
    "alex.aravena.p@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:35",
    "19 de mayo de 2023  14:47",
    "11 minutos 47 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos con la misma prioridad son procesados en orden aleatorio",
    "Verdadero",
    "El árbol B\/B+ es útil para aplicaciones en las que las claves cambian con frecuencia, ya que es fácil actualizar los nodos",
    "Verdadero",
    "Un grafo es útil cuando queremos analizar redes de comunicaciones, ya que los grafos pueden ser utilizados para identificar nodos críticos y patrones de comunicación",
    "Verdadero",
    "Un montículo binario se puede utilizar para implementar una cola de prioridad",
    "Verdadero",
    "En un árbol B+, las hojas contienen todos los datos almacenados en el árbol, mientras que los nodos internos solo contienen claves para dividir los datos en subárboles",
    "Verdadero",
    "La búsqueda en anchura encuentra la solución óptima para problemas de camino más corto.",
    "Verdadero",
    "Los árboles B son ideales para el acceso secuencial de datos",
    "Verdadero",
    "Un montículo binario puede tener múltiples elementos con el mismo valor",
    "Verdadero",
    "La complejidad espacial de un árbol B+ es mayor que la de un árbol B debido a que los nodos internos almacenan más claves.",
    "Verdadero",
    "Teniendo un mapa de una ciudad, donde la clave es el nombre de la calle y el valor es el tipo de calle (residencial, comercial, etc.). ¿Cómo implementarías una función para encontrar todas las calles comerciales?",
    "Para encontrar todas las calles comerciales recorrería el mapa, revisando cada valor, si encuentro un valor de tipo comercial, significa que se encontró y se hace lo que quiera con el, así sucesivamente. Si se quieren ir guardando en una lista, se guardan en una lista.",
    "Tenemos un mapa de productos, donde cada producto tiene una lista de precios de diferentes proveedores. ¿Cómo podría implementar una función para encontrar el proveedor más barato para cada producto?",
    "Recorrería el mapa nodo por nodo, y revisaría cada lista, encontrando así el proveedor más barato para un producto, ahora esto lo llevaría a otro mapa de proveedores más baratos, entonces la clave sería el producto, y el valor sería ese proveedor.",
    "Considere que tenemos un mapa de tareas, en donde cada tarea tiene una lista de tareas precedentes. Describa un algoritmo que imprima las tareas en un orden en que puedan realizarse (tomando en cuenta relación de precedencia).",
    "Primero, recorrería el mapa y guardaría las tareas sin precedentes en una lista, luego las tareas con precedentes en otra lista. Primero se mostrarán las tareas que no tienen precedentes, y se marcarán como completadas. La lista de las tareas que tienen precedentes se recorren, entonces, se revisan sus tareas precedentes por tarea, si tiene todas las tareas precedentes completadas, se muestra esa tarea, sino, pasa a la siguiente, en el caso de que tenga todas sus tareas precedentes marcadas como completadas, esta tarea se muestra, se marca como completada y se elimina de la lista de las tareas que tienen precedentes."
],[
    "PEREZ JERIA",
    "TOMAS ABDIEL",
    "tomas.perez.j@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  08:36",
    "19 de mayo de 2023  08:57",
    "21 minutos 27 segundos",
    "Sin calificar aún",
    "Es recomendable usar colas con prioridad cuando todos los elementos tienen la misma prioridad",
    "Falso",
    "En un árbol B, todas las hojas se encuentran en el mismo nivel",
    "Verdadero",
    "Se puede usar grafos para modelar relaciones entre entidades, ya que los grafos permiten representar de forma clara y concisa las relaciones complejas entre elementos",
    "Verdadero",
    "Un montículo binario solo puede ser utilizado para elementos de tipo numérico, ya que la propiedad de ordenación se basa en la comparación de valores numéricos",
    "Falso",
    "En un árbol B+, los datos están organizados en orden ascendente en cada hoja y las hojas están enlazadas",
    "Verdadero",
    "La búsqueda en anchura utiliza una cola para almacenar los nodos a visitar.",
    "Verdadero",
    "A diferencia de los arreglos ordenados, las tablas hash pueden tener un tiempo de acceso constante para la búsqueda de elementos",
    "Verdadero",
    "La búsqueda de un elemento en un montículo tiene complejidad O(n)",
    "Falso",
    "La inserción en un árbol B+ tiene complejidad temporal O(log n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "¿Cómo podríamos implementar una función que tome una lista de palabras y retorne las palabras ordenadas de acuerdo a su longitud? (use TDAs y no algoritmos de ordenamiento)",
    "para esta ocasión usaremos el toda de mapa no ordenado, ya que se puede implementar para contar cuales palabras y cuantas veces aparece en un texto, podemos en esta ocasión en el struct donde se guarda cada dato de la palabra (la palabra en si, y su longitud por medio de la función strlen()) donde podemos aprovechar este ultimo dato como la clave o llave para acceder a cada valor en el mapa, y con ello podremos acceder a la palabra de menor largo, de manera sucesiva, pasando por cada palabra y mostrando su longitud.",
    "Tenemos un mapa de libros, donde cada libro tiene una lista de reseñas de usuarios. ¿Cómo podríamos calcular el número de usuarios que han calificado el libro \"Cien años de soledad\" con 5 estrellas?",
    "en esta ocasión interpretaremos que se encuentra en un mapa ordenado y que además las calificaciones se representan solamente en números enteros . para poder realizar la función, primero accedemos a el dato en el mapa correspondiente al libro en cuestión, tras esto, podemos crear un vector de frecuencias, que en vez de ir almacenando un valor en si en cada espacio, estará almacenando cuantas apariciones tuvo una calificación, tomando esto en cuenta, podemos crear este vector de manera estática con 6 espacio de 0 a 5 representando la cantidad de estrellas de cada calificación, para luego ir aumentando en 1 cada espacio del vector, de acuerdo a las reglas mencionadas, para finalmente solo saber el valor que contiene el vector[5] para calcular el numero de usuarios que calificaron con 5 estrellas.",
    "Considere que tenemos un mapa de tareas, en donde cada tarea tiene una lista de tareas precedentes. Describa un algoritmo que imprima las tareas en un orden en que puedan realizarse (tomando en cuenta relación de precedencia).",
    "tomaremos en cuenta que cada tarea se encuentra en un mapa ordenado y que no existe un dato de prioridad. en primer lugar revisamos cada nodo de el mapa, revisando si la tarea contiene alguna tarea precedente, si la tarea no contiene una tarea precedente, simplemente se imprime la tarea en si, de lo contrario, imprimimos las tareas, las marcamos como visitadas, y si en algún nodo, su tarea ya se encuentra visitada esta se ignora debido a que ya a sido imprimida, y seguimos este procedimiento hasta acabar el mapa. "
],[
    "GUZMAN ELGUETA",
    "VALENTINA IGNACIA",
    "valentina.guzman.e@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:46",
    "19 de mayo de 2023  15:06",
    "19 minutos 33 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, es posible tener elementos con la misma prioridad pero con diferentes tiempos de llegada",
    "Verdadero",
    "En un árbol B, la altura máxima del árbol depende del número de claves y el orden del árbol (cantidad máxima de nodos por hoja)",
    "Falso",
    "Un grafo es útil cuando queremos optimizar el flujo de recursos en una red, como el suministro de energía o la distribución de agua, ya que los algoritmos de flujo en grafos pueden encontrar la ruta más eficiente para distribuir los recursos",
    "Verdadero",
    "Podemos usar un montículo binario para encontrar el k-ésimo elemento más pequeño de una lista: construimos un montículo a partir de la lista original y luego eliminamos los k-1 elementos más pequeños de manera secuencial. El elemento siguiente es el k-ésimo elemento más pequeño",
    "Verdadero",
    "En un árbol B+, los nodos internos pueden contener datos además de las claves",
    "Verdadero",
    "La búsqueda en anchura es una buena opción para grafos con una profundidad desconocida.",
    "Verdadero",
    "A diferencia de los arreglos ordenados, las tablas hash pueden tener un tiempo de acceso constante para la búsqueda de elementos",
    "Verdadero",
    "La búsqueda de un elemento en un montículo tiene complejidad O(n)",
    "Verdadero",
    "La complejidad temporal de la búsqueda en un árbol B es O(log n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "¿Cómo implementaría una cola de prioridad para administrar las solicitudes de atención al cliente en un sistema de soporte técnico, donde los clientes VIP tienen la más alta prioridad, seguidos por los clientes habituales y luego los nuevos clientes?",
    "para implementar la cola de prioridad (con montículo binario), habría que establecer la prioridad de los clientes vip, habituales y nuevos.\nlos vip tienen prioridad 3, si hay más de un cliente vip (todos los que existan), serán atendidos por el orden de llegada de su solicitud, el que haya enviado antes la solicitud será el primer atendido de los que tengan prioridad 3.\n\nlos habituales tienen prioridad 2: serán atendidos por el orden de llegada de su solicitud, el que haya enviado antes la solicitud será el primer atendido de los que tengan prioridad 2.\n\nlos nuevos tienen prioridad 1: serán atendidos por el orden de llegada de su solicitud, el que haya enviado antes la solicitud será el primer atendido de los que tengan prioridad 1.\n\nPOR LO TANTO, se atenderían todos los prioridad 3, luego todos los prioridad 2 y finalmente los prioridad 1",
    "Considere que tenemos un mapa de estudiantes, donde cada estudiante tiene una lista de cursos y las notas obtenidas en cada curso. ¿Cómo podría implementar una función para encontrar el curso en el que los estudiantes tienen el promedio de notas más bajo?",
    "mapa:\n\nclave= rut\n\nvalor = lista de cursos, con las notas respectivas que tienen en cada ramo\n\nYa que quiero saber el curso en el que tiene más bajo el promedio de notas el alumno, debo ingresar al estudiante a través de la clave y recorrer la lista de cursos utilizando un auxiliar que vaya comparando con cada promedio de cada ramo hasta que se encuentre el curso en el que el estudiante vaya peor.\n\nSi quiero saber el curso en el los estudiants tienen el promedio de nota más bajo, debo recorrer a cada uno de los alumnos, y crear un arreglo que contenga el curso en el que le va peor a cada alumno (clave rut, valor nombre del curso en el que tienen peor prom), luego tendría que crear contadores inicializados en 0 para cada ramo e ir recorriendo el arreglo, ir sumando +1 al contador cada vez que se encuentre un estudiante que su peor promedio corresponda a dicha materia.\n\nTa habiendo recorrido todo, se pueden comparar los contadores, el que sea mayor será la materia con más alumnos teniendo su peor promedio en ella (la materia en la que a más gente le va peor)",
    "Describe un algoritmo que verifique si un grafo dirigido contiene un ciclo, utilizando una pila.",
    "--"
],[
    "PIÑA VERA",
    "FABIANA ANDREA",
    "fabiana.pina.v@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  08:12",
    "19 de mayo de 2023  08:42",
    "29 minutos 59 segundos",
    "Sin calificar aún",
    "Se puede utilizar colas con prioridad para acelerar el procesamiento de datos",
    "Falso",
    "Los árboles B son similares a los árboles AVL en términos de estructura",
    "Verdadero",
    "Se puede usar grafos para modelar sistemas de recomendación, como en aplicaciones de comercio electrónico o de películas, ya que los grafos pueden representar las preferencias de los usuarios y las relaciones entre productos o películas",
    "Verdadero",
    "Un montículo binario se puede utilizar para implementar una cola de prioridad",
    "Verdadero",
    "Para eliminar un dato en un árbol B, basta con buscar la clave y eliminarla del nodo correspondiente. Si el nodo se queda sin claves, debemos realizar una fusión.",
    "Falso",
    "La búsqueda en profundidad consume más memoria que la búsqueda en anchura en grafos anchos.",
    "Falso",
    "A diferencia de los arreglos ordenados, las tablas hash pueden tener un tiempo de acceso constante para la búsqueda de elementos",
    "Verdadero",
    "La búsqueda de un elemento en un montículo tiene complejidad O(n)",
    "Falso",
    "La complejidad temporal de la inserción en un árbol B es O(n) debido a que se deben realizar varias divisiones y fusiones de nodos",
    "Falso",
    "¿Cómo podríamos implementar una función que tome una lista de palabras y retorne las palabras ordenadas de acuerdo a su longitud? (use TDAs y no algoritmos de ordenamiento)",
    "Para implementar una función que  tome un lista de palabras y retorne las palabras ordenadas de acuerdo con su longitud puede ser de la siguiente manera:\n\n- Comienza recorriendo la lista de palabra.\n\n- Para calcular la longitud de la palabra, se debe recorrer toda la palabra hasta encontrar un salto de línea y el valor debe ser guardado una variable numLongiutd.\n\n- Se crea un mapa ordenada para guardar las palabras como clave y que su longitud sea el valor.\n\nY para retornar se recorre el mapa ordenado.",
    "Considere un mapa de pacientes en un hospital, donde cada paciente tiene una lista de medicamentos que están tomando. ¿Cómo podría implementar una función para encontrar todos los pacientes que están tomando un medicamento específico?",
    "Para implementar una función en donde se encuentre todos los pacientes que están tomando un medicamento especifico, se puede realizar de la siguiente manera:\n\n- Se crea una lista con los pacientes (pacienteMedicamentoEspecifico) que toman ese medicamento en especifico.\n\n- Se recorre el mapa de pacientes y se ingresa a la lista de los medicamentos que toma, y se recorre esa lista donde se compara el medicamento que toma con el buscado y en caso que sean iguales, el nombre del paciente se debe copiar a la lista de pacienteMedicamentoEspecifico.",
    "Explique cómo podría implementar una cola con prioridad, usando 2 pilas. ¿Como realizaría inserciones y eliminaciones en la cola con prioridad?",
    "Para realizar inserciones en la cola con prioridad con prioridad insertar en la pila1 y en la cola con prioridad y en caso que que se deba inserta al medio de la cola se utiliza la pila2 y cambiando de la pila 1 a la 2 e insertando en la posicion adecuada"
],[
    "NAVEA MUÑOZ",
    "NIKOLAI LUKAS",
    "nikolai.navea.m@mail.pucv.cl",
    "Finalizado",
    "18 de mayo de 2023  12:38",
    "18 de mayo de 2023  13:06",
    "28 minutos 7 segundos",
    "Sin calificar aún",
    "Se puede usar colas con prioridad para almacenar los nodos en un algoritmo de búsqueda en grafos",
    "Verdadero",
    "El árbol B\/B+ es útil para la implementación de bases de datos, ya que permite una rápida recuperación de datos y una fácil actualización de los mismos",
    "Verdadero",
    "Un grafo es útil cuando queremos analizar redes de comunicaciones, ya que los grafos pueden ser utilizados para identificar nodos críticos y patrones de comunicación",
    "Verdadero",
    "Un montículo binario es una estructura de datos eficiente para ordenar grandes cantidades de datos en memoria RAM",
    "Falso",
    "La complejidad de la operación de búsqueda en un árbol B es O(log n)",
    "Verdadero",
    "La búsqueda en profundidad consume más memoria que la búsqueda en anchura en grafos anchos.",
    "Falso",
    "Las listas enlazadas son más eficientes que los arreglos para insertar o eliminar elementos en posiciones aleatorias de la estructura",
    "Verdadero",
    "La complejidad espacial de un montículo binario es O(n), ya que todos los elementos se almacenan en el árbol",
    "Falso",
    "La búsqueda en un árbol B tiene complejidad temporal O(n), donde n es el número de elementos en el árbol.",
    "Falso",
    "Imagina que tienes un mapa con las calificaciones de los estudiantes, donde la clave es el nombre del estudiante y el valor es su calificación. ¿Cómo podrías implementar una función para encontrar a todos los estudiantes que aprobaron (calificación mayor a 5)?",
    "Para implementar una funcion que encuentra a todos los estudiantes que aprobaron, se podría crear una lista que contendrá el nombre de todas las personas que aprobaron(calificación mayor a 5), en esta función se le pasa el mapa, y se va revisando si los estudiantes aprobaron o no, dependiendo de la calificación que tienen en su mapa, los que tienen una calificación mayor a 5 se guarda el nombre en la lista. Al final de la funcion vamos a tener una lista llena de los nombres de los alumnos que aprobaron el ramo o la prueba",
    "Tenemos un mapa de productos, donde cada producto tiene una lista de precios de diferentes proveedores. ¿Cómo podría implementar una función para encontrar el proveedor más barato para cada producto?",
    "Para implementar esta función, se necesita el mapa del producto para así entrar a la lista de precios de los proveedores. Se crea una variable con nombre barato que se inicializa en el precio del primer proveedor, y se va recorriendo la lista comparando con los precios y se actualiza dependiendo si el siguiente precio es menor al de la variable, al final de recorrer la lista deberiamos tener al proveedor con menor precio",
    "Describa un algoritmo para implementar una pila utilizando dos colas.",
    "Asumiendo que las colas tienen la misma variable para el dato dentro de la estructura y que una cola se implementa a la pila antes y también asumo que al decir implementar se refiere a implementar la TDA pila teniendo dos colas\n1. Se inicializa una pila vacía\n2. En la función de inserción, se crea una variable que sea el primer valor de la cola y se van insertando al primer nodo de la pila, hasta que el siguiente nodo de la cola sea NULL después se hace un clean al dejar de ocupar la cola, para así liberar la memoria ocupada por los datos que la cola tuvo\n3. Para implementar a la segunda cola, se crea una variable que sea el primer valor de la segunda cola, y se comienza desde donde termino la cola anterior, hasta que el siguiente nodo de la cola sea NULL después se hace un clean al dejar de ocupar la cola, para así liberar la memoria ocupada por los datos que la cola tuvo\nAl hacer estos pasos, se crearia una pila con los datos que tuvieron las dos colas"
],[
    "SOLIS PIÑONES",
    "FABIAN ANDRES",
    "fabiansolisp@gmail.com",
    "Finalizado",
    "19 de mayo de 2023  14:56",
    "19 de mayo de 2023  15:26",
    "30 minutos",
    "Sin calificar aún",
    "En una cola con prioridad, la prioridad de un elemento se determina por un valor asociado a dicho elemento",
    "Verdadero",
    "En un árbol B, la inserción siempre se realiza en las hojas. (Aunque luego es posible que el nuevo dato suba a causa de una división de nodos)",
    "Verdadero",
    "Es útil usar grafos para mantener datos ordenados por claves y realizar búsquedas por prioridad.",
    "Falso",
    "Un montículo binario puede ser implementado utilizando un arreglo.",
    "Verdadero",
    "En un árbol B+, las hojas contienen todos los datos almacenados en el árbol, mientras que los nodos internos solo contienen claves para dividir los datos en subárboles",
    "Falso",
    "La búsqueda en anchura es una buena opción para grafos con una profundidad desconocida.",
    "Verdadero",
    "A diferencia de la tabla hash, los árboles B+ pueden trabajar con grandes volúmenes de datos.",
    "Verdadero",
    "La inserción en un montículo tiene complejidad O(log n) en el peor de los casos, ya que debemos asegurarnos de mantener la propiedad del montículo al acomodar los elementos",
    "Verdadero",
    "Un árbol B+ tiene una altura de entre 2 y 5 niveles.",
    "Falso",
    "¿Cómo podríamos implementar una función que tome una lista de palabras y retorne las palabras ordenadas de acuerdo a su longitud? (use TDAs y no algoritmos de ordenamiento)",
    "Para realizar esto se puede usar un monticulo minimo. Primero se reocorre la lista y se calcula la longitud de la palabra con una funcion que cuente los caracteres de cada una, despues se ingresa la palabara y su longitud al monticulo (la prioridad es la longitud). Luego ingresar todas las palabras se va sacando la raiz del monticulo e imprimiendo la palabra, hasta que no hayan mas datos en el monticulo, de esta forma se  mostraran ordenadas (de menor a mayor caracteres).",
    "Supongamos que tenemos un mapa de autores, donde cada autor tiene una lista de libros que ha escrito. Cada libro incluye título, género y calificación promedio. ¿Cómo implementarías una función para calcular la calificación promedio de los libros del género de aventuras?",
    "Para realizar esto hay que tener una variable suma y un contador. Primero se recorre el mapa de autores y cada lista de los generos de los autores, al recorrer la lista de generos, se compara el genero de aventuras y el genero que tiene ese artista en esa posición de la lista (así con todos los datos de la lista), al ser iguales se suma la calificacion a la variable suma (inicializada en 0) y se aumenta el contador (así con todos los datos del mapa). Al final para saber la calificación promedio de los libros del género de aventuras, solo se divide la suma total con el contador y daría el promedio.",
    "Describe el algoritmo de búsqueda en anchura (BFS, por sus siglas en inglés) en un grafo, utilizando una cola.",
    "Se utiliza la cola para mantener un seguimiento de los nodos a visitar. Primero parte con un nodo de inicio, se marca como visitado y se inserta en la cola. Después, mientras la cola no esté vacía, se extrae un nodo de la cola, y se inserta sus vecinos no visitados en la cola."
],[
    "SEPULVEDA CABRERA",
    "JAVIER ARTURO",
    "psoficialjavo0408@gmail.com",
    "Finalizado",
    "19 de mayo de 2023  14:25",
    "19 de mayo de 2023  14:47",
    "22 minutos 29 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos con la misma prioridad son procesados en orden aleatorio",
    "Falso",
    "El árbol B\/B+ es útil para búsquedas en tiempo constante, ya que todos los nodos tienen el mismo tamaño",
    "Falso",
    "Es útil usar grafos para mantener datos ordenados por claves y realizar búsquedas por prioridad.",
    "Falso",
    "En un montículo binario, la búsqueda de un elemento se realiza en tiempo constante",
    "Falso",
    "En un árbol B+, los nodos internos pueden contener datos además de las claves",
    "Verdadero",
    "La búsqueda en profundidad utiliza una cola para almacenar los nodos a visitar.",
    "Falso",
    "Los arreglos son más eficientes que las listas enlazadas para acceder al i-ésimo elemento",
    "Verdadero",
    "La altura máxima de un montículo binario con n elementos es log₂(n)",
    "Falso",
    "La complejidad espacial de un árbol B+ es mayor que la de un árbol B debido a que los nodos internos almacenan más claves.",
    "Verdadero",
    "¿Cómo implementaría una cola de prioridad para administrar las solicitudes de atención al cliente en un sistema de soporte técnico, donde los clientes VIP tienen la más alta prioridad, seguidos por los clientes habituales y luego los nuevos clientes?",
    "Podemos crear una estructura para clasificar al cliente por nombre y su estatus, osea VIP, cliente habitual y cliente nuevo.\nLuego los elementos de la cola con prioridad se implementarán utilizando un montículo binario, donde cada elemento de la cola tiene un valor de prioridad asociado al estatus del cliente.\n\nEl montículo binario se encarga de ordenar la cola con prioridad, y luego para administrar las solicitudes, basta con extraer el primer elemento de la cola, que serán los VIP en primer lugar.",
    "Tenemos un mapa de productos, donde cada producto tiene una lista de precios de diferentes proveedores. ¿Cómo podría implementar una función para encontrar el proveedor más barato para cada producto?",
    "La función creará una lista para almacenar los precios más baratos y el proveedor del cual vienen. Luego recorrerá el mapa y las listas, para cada producto, creará un montículo binario de mínimos, este recorrerá de nuevo el mapa y las listas, encontrando los precios del producto actual y el nombre del proveedor de tal precio.\nLuego de recorrer completamente el mapa y las listas, se extrae el primer elemento del montículo (el precio más barato) y se ingresa en la lista el nombre del producto, el precio y el nombre del proveedor.",
    "Diseña un algoritmo que permita verificar si un grafo es un árbol utilizando DFS o BFS.",
    "Podemos modelar un grafo y implementar cualquiera de los dos, DFS o BFS, empezamos en un nodo inicial del grafo y una lista para almacenar los nodos visitados. \n\nAgrega el nodo inicial a la lista y marca el nodo como visitado. Mientras la estructura de datos no esté vacía, realiza lo siguiente, retirará el nodo actual de la lista y recorrerá todos los nodos adyacentes del nodo actual. Si algún nodo adyacente no ha sido visitado, se agrega a la estructura de datos y se marca como visitado. \n\nAl finalizar el recorrido, verifica si todos los nodos del grafo han sido visitados y si todos los nodos han sido visitados, el grafo es un árbol."
],[
    "ARRATIA CAROCA",
    "VICENTE ANDRE",
    "vicente.arratia.c@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:25",
    "19 de mayo de 2023  14:55",
    "29 minutos 56 segundos",
    "Sin calificar aún",
    "Se puede usar colas con prioridad para almacenar los nodos en un algoritmo de búsqueda en grafos",
    "Verdadero",
    "En un árbol B, la altura máxima del árbol depende del número de claves y el orden del árbol (cantidad máxima de nodos por hoja)",
    "Verdadero",
    "Un grafo es útil cuando queremos analizar patrones de tráfico en internet, ya que los grafos pueden representar los flujos de datos entre diferentes sistemas y los nodos críticos en la red",
    "Verdadero",
    "La altura de un montículo binario con n elementos es logarítmica en n",
    "Verdadero",
    "En un árbol B, el número de claves en cada nodo es fijo",
    "Falso",
    "La búsqueda en profundidad consume más memoria que la búsqueda en anchura en grafos anchos.",
    "Falso",
    "A diferencia de los montículos, los arreglos ordenados mantienen la posición relativa de los elementos",
    "Verdadero",
    "La altura máxima de un montículo binario con n elementos es log₂(n)",
    "Verdadero",
    "La complejidad temporal de la inserción en un árbol B es O(1)",
    "Falso",
    "Suponga que tiene un conjunto de operaciones a realizar, cada una con un tiempo de duración diferente. ¿Cómo podría usar una cola de prioridad para ordenar las operaciones de manera que se realicen primero las más cortas?",
    "Podemos implementar un montículo binario de mínimos, donde en la raíz se ira guardando aquella de operación que tenga el menor tiempo de duración. Lo que ordenaría las operaciones de forma satisfactoria a lo pedido. (Ordenar las operaciones de manera que se realicen primo las más cortas).",
    "Supongamos que tenemos un mapa de usuarios de un sitio web, donde cada usuario tiene una lista de productos que ha comprado. ¿Cómo podría implementar una función para encontrar el producto más comprado?",
    "Habría que recorrer el mapa de usuarios accediendo a la lista de productos de cada usuario. Podríamos implementar un mapa que contenga todos los productos posibles que pudo haber comprado el usuario \"x\", este mapa almacenará un struct que contiene el nombre del producto junto a un contador que indicará cuantas veces se compro ese producto. Con esto en mente recorreremos el mapa, accederemos a la lista del usuario \"x\" e iremos comparando (recorriendo) con el mapa auxiliar que contiene los productos, en caso de haber alguna coincidencia se sumara al contador 1 (cont++). Al haber terminado este ciclo recorreremos el mapa auxiliar y buscaremos aquel producto que contenga el cont con mayor valor, ya que esto indica que ese producto fue el más comprado por los usuarios.",
    "Dado un laberinto representado como una matriz de celdas, describe un algoritmo que encuentre un camino desde la entrada hasta la salida utilizando una pila.",
    "Al tratarse de un laberinto y búsqueda del camino desde la entrada hasta la salida, se asume que hay un grafo, donde cada nodo representará un estado. Cada estado será la misma matriz con un movimiento de por ejemplo una persona, lo que se marcará con 1. El alrededor que sea muro se representará como 9 y los espacios movibles son marcados con 0. Con esto en mente podemos implementar el algoritmo de búsqueda en profundidad, el cual mediante una pila y una serie de operaciones en esta misma determinará el camino que lleva hasta la salida del laberinto. En esta solo se almacenan los nodos de una rama del árbol. (árbol debido a que esta búsqueda tienen un aspecto de un árbol, lo que se conoce como árbol de búsqueda)."
],[
    "FUENTES JIMENEZ",
    "HECTOR IGNACIO",
    "hectorfuentesj3@gmail.com",
    "Finalizado",
    "18 de mayo de 2023  12:45",
    "18 de mayo de 2023  13:14",
    "29 minutos 25 segundos",
    "Sin calificar aún",
    "Las colas con prioridad pueden ser utilizadas para el ordenamiento de elementos en un arreglo",
    "Falso",
    "El árbol B\/B+ es útil para búsquedas en tiempo constante, ya que todos los nodos tienen el mismo tamaño",
    "Falso",
    "Un grafo es útil cuando queremos analizar patrones de tráfico en internet, ya que los grafos pueden representar los flujos de datos entre diferentes sistemas y los nodos críticos en la red",
    "Verdadero",
    "Un montículo binario es una estructura de datos que permite mantener una colección de elementos ordenados en función de su valor, con una complejidad de tiempo logarítmica para las operaciones de inserción, eliminación y búsqueda",
    "Verdadero",
    "Un árbol B generalmente tiene una altura mayor a la de un árbol de búsqueda binaria normal",
    "Falso",
    "La búsqueda en profundidad consume más memoria que la búsqueda en anchura en grafos anchos.",
    "Falso",
    "A diferencia de las tablas hash, los árboles binarios no tienen un orden definido para los elementos almacenados",
    "Falso",
    "La inserción en un montículo tiene complejidad O(log n) en el peor de los casos, ya que debemos asegurarnos de mantener la propiedad del montículo al acomodar los elementos",
    "Verdadero",
    "La complejidad espacial de un árbol B es O(n log n)",
    "Falso",
    "Imagina que tienes un mapa con las calificaciones de los estudiantes, donde la clave es el nombre del estudiante y el valor es su calificación. ¿Cómo podrías implementar una función para encontrar a todos los estudiantes que aprobaron (calificación mayor a 5)?",
    "Podría implementar una función que al momento de recorrer el mapa que se encontrarían los estudiantes y sus calificación, usar un tipo de condición, que pudiese ser un if y crear un tipo de selección o filtro que si la calificación es mayor o igual a 5  se imprima la clave, que en este caso estaría correspondiendo al nombre del estudiante, y asi pudiendo mostrar solo los estudiantes que tienen respectiva calificación. ",
    "Tenemos un mapa de artistas. Cada artista, además del nombre, tiene una lista de géneros musicales asociados (rock, pop, jazz, clásico, etc.) ¿Cómo podríamos imprimir el número de artistas asociados a cada género, indicando el género más popular?",
    "Para implementar esta funcion puedo ir recorriendo cada artista y que en cada uno de los artistas que pase, crear un contador respectivo inicializado en 1 ya que se supone que leyo ese genero musical para crearlo, según el genero musical, cuando ingrese al genero musical verificar si ya se tiene un contador creado para ese estilo musical a traves de una condicion que que recorra los contadores creados con el estilo de musica y si encuentra un contador inicializado en 1  igual al nombre del estilo musica se incrementaria en 1, ejemplo rock++; ,",
    "Describe un algoritmo de Breadth-First Search (BFS) para encontrar el camino más corto entre un nodo A y un nodo B (la distancia entre par de nodos conectados es 1).",
    "para encontrar  el camino mas corto entre nodos , se puede inicializar una cola en este caso en 0,  y en el momento que visite el nodo A agregarlo a la cola y marcarlo como visitado, y luego crear un tipo de condicion que verifique que ya paso por el nodo A es decir que la cola no se encuentre vacia y mientras la cola no este vacia se extrae el primer elemento de la cola y Si el nodo extraído es igual al nodo B, hemos encontrado el camino más corto. ME QUEDE SIN TIEMPO AAAAAAA"
],[
    "FIESTA INOCENTE",
    "DENILSON",
    "denilson.fiesta@ucb.edu.bo",
    "Finalizado",
    "18 de mayo de 2023  12:22",
    "18 de mayo de 2023  12:45",
    "23 minutos 37 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos con la misma prioridad son procesados en orden aleatorio",
    "Falso",
    "Los árboles B+ son una variante de los árboles B, donde los nodos hoja contienen registros de datos",
    "Verdadero",
    "Un grafo es útil cuando queremos modelar sistemas de control, como los circuitos eléctricos o los sistemas de producción, ya que los grafos permiten representar las conexiones entre los elementos y analizar cómo afecta una perturbación a todo el sistema",
    "Verdadero",
    "Un montículo binario es una estructura de datos que permite mantener una colección de elementos ordenados en función de su valor, con una complejidad de tiempo logarítmica para las operaciones de inserción, eliminación y búsqueda",
    "Falso",
    "En un árbol B, la operación de eliminación siempre implica la reorganización completa del árbol",
    "Verdadero",
    "La búsqueda en profundidad puede ser implementada de manera recursiva.",
    "Verdadero",
    "Las tablas hash son más eficientes que los arreglos y las listas enlazadas para buscar elementos en la estructura",
    "Verdadero",
    "La altura máxima de un montículo binario con n elementos es log₂(n)",
    "Verdadero",
    "La complejidad temporal de la inserción en un árbol B es O(1)",
    "Falso",
    "Imagina que tienes un mapa con las calificaciones de los estudiantes, donde la clave es el nombre del estudiante y el valor es su calificación. ¿Cómo podrías implementar una función para encontrar a todos los estudiantes que aprobaron (calificación mayor a 5)?",
    "Primeramente deberia recorrer el mapa desde el inicio, y por cada par encontrado en el mapa revisaria si su clave que representa la calificacion del estudiante es mayor a 5, si es que se cumple en caso de ser necesario se podria almacenar el nombre del estudiante en un lista o dependiendo de lo que se quiera hacer con los estudiantes aprobados.",
    "Considere que tenemos un mapa de países, donde cada país tiene una lista de sus ciudades y cada ciudad tiene su población. ¿Cómo podría implementar una función para encontrar el país con la mayor población total?",
    "Deberia iterarse sobre el mapa de paises. Y por cada par obtenido que representaria al pais y su lista de ciudades, deberia de recorrer esa lista de ciudades y sacar una acumulada de la poblacion total del pais en base a las ciudades del pais, y asi al finalizar la iteracion de las ciudades hacer lo mismo con los otros paises para luego ir comparando esa poblacion total por cada pais encontrado en el mapa, y por ultimo retornar aquel pais con la mayor poblacion total",
    "Considere que tenemos un mapa de tareas, en donde cada tarea tiene una lista de tareas precedentes. Describa un algoritmo que imprima las tareas en un orden en que puedan realizarse (tomando en cuenta relación de precedencia).",
    "Para este ejercicio, se podria utilizar el algoritmo de orden topologico, el cual se describiria de la siguiente manera para el ejercicio:\n\nSe recorrera el mapa desde el valor mayor dependiendo de la prioridad y por cada tarea obtenida se le pasara a la funcion del orden topologico. Recordar que para realizar el orden topologico se debera utilizar una lista o pila para guardar la salida, como tambien alguna estructura que me permita verificar si alguna tarea ya fue revisada durante el algoritmo. Continuando con la funcion esta se decribe de la siguiente manera: Si es que la tarea en la funcion ya fue revisada entonces termina la funcion caso contrario; marcar o indicar que la tarea esta siendo revisada, luego iterar sobre su lista de precedencia que contiene dicha tarea, y por cada tarea encontrada pasaremo a la funcion de orden topologico(inicio de la recursividad), una vez terminada la iteracion agregamos la tarea a la lista o pila. Y asi hasta revisar todas las tareas que se tiene sobre el mapa de tareas.\n\nvoid topological sort(tarea){\n  si tarea revisada return;\n  tarea fue revisada;\n  tareaPrecedente = rfirst(tarea.listaPrecedentes);\n \n  mientras tareaPrecedente exista:\n    ordentopologico(tareaPrecedente)\n    tareaPrecedente = rnext(tarea.listaPrecedentes)\n  fin  mientras\n    \n  \/\/se imprime o se agrega a un lista o pila la tarea\n}\n\nmain (){\n \n  tarea = rfirst(mapaTareas);\n   mientras tarea exista:\n    ordentopologico(tarea)\n    tarea= rnext(mapaTareas)\n  fin  mientras\n\n}"
],[
    "CATALAN VILLANUEVA",
    "ALVARO ANGEL",
    "alvaro.catalan.v@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  08:12",
    "19 de mayo de 2023  08:30",
    "18 minutos 1 segundos",
    "Sin calificar aún",
    "Es recomendable usar colas con prioridad cuando todos los elementos tienen la misma prioridad",
    "Falso",
    "El árbol B\/B+ es útil para la implementación de algoritmos de búsqueda en grafos, ya que permite una rápida búsqueda de nodos y aristas",
    "Falso",
    "Un grafo es útil cuando queremos encontrar la ruta más corta entre dos nodos, ya que los algoritmos de búsqueda de caminos en grafos son muy eficientes",
    "Verdadero",
    "Un montículo binario se puede utilizar para implementar una cola de prioridad",
    "Verdadero",
    "En un árbol B+, las hojas contienen todos los datos almacenados en el árbol, mientras que los nodos internos solo contienen claves para dividir los datos en subárboles",
    "Verdadero",
    "La búsqueda en profundidad puede ser implementada de manera recursiva.",
    "Verdadero",
    "A diferencia de la tabla hash, los árboles B+ pueden trabajar con grandes volúmenes de datos.",
    "Verdadero",
    "La complejidad espacial de un montículo binario es O(n), ya que todos los elementos se almacenan en el árbol",
    "Verdadero",
    "La complejidad temporal de la búsqueda en un árbol B es O(log n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "Describa cómo se puede utilizar un conjunto o mapa para verificar si una lista tiene elementos duplicados.",
    "primero al momento de insertar el primer elemento en la lista se va guardando también en un mapa(caso de ser el primer elemento se crea el mapa y el primer elemento de este es el primer elemento de la lista). al momento de ingresar un nuevo elemento se busca ese elemento dentro del mapa de encontrarse un choque de keys se da el aviso de que el elemento se encuentra duplicado",
    "Tenemos un mapa de empleados, cada uno con una lista de proyectos en los que han trabajado y el tiempo que dedicaron a cada uno. ¿Cómo podría implementar una función para encontrar el empleado que ha dedicado más tiempo a los proyectos?",
    "bueno esto depende de si en la lista proyectos se encuentra una variable tipo horas y ya que piden el mayor tiempo en todos los proyectos del empleado seria iniciar en el primer empleado para verificar la cantidad de horas utilizadas en sus proyectos en base a eso guardar la cantidad de horas en una variable de tipo int despues ir comparando con cada empleado si un empleado2 tiene mayor horas que el empleado con el que se esta evaluando se cambia y la busqueda comienza desde ese empleado2 que pasaria a ser empleado1 utilizaria una variable auxiliar de tipo empleado la cual tendria lo siguiente char empleado[30]; y int horas; ",
    "Describe un algoritmo que verifique si un grafo dirigido contiene un ciclo, utilizando una pila.",
    "se partiria en el primer punto del gafo tomado como su head y se realizaria una busqueda en profundidad utilizando la pila para ir guardando los nodos hijos de cada nodo e ir revizando con la condicion de que se vaya guardando el primer nodo revisado se colocaria la condicion if(nodovader==nodoluke) se daria la alerta de que el grafo presenta un ciclo en sus nodos"
],[
    "VASQUEZ ORELLANA",
    "MARTIN IGNACIO",
    "martin.vasquez.o@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:28",
    "19 de mayo de 2023  14:44",
    "16 minutos 38 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos con la misma prioridad son procesados en orden aleatorio",
    "False",
    "Los árboles B son similares a los árboles AVL en términos de estructura",
    "False",
    "Un grafo es útil cuando queremos analizar patrones de tráfico en internet, ya que los grafos pueden representar los flujos de datos entre diferentes sistemas y los nodos críticos en la red",
    "True",
    "Un montículo binario puede ser implementado utilizando un arreglo.",
    "True",
    "En un árbol B, la operación de búsqueda tiene una complejidad de tiempo constante, independientemente del número de elementos almacenados en el árbol",
    "False",
    "La búsqueda en profundidad utiliza una cola para almacenar los nodos a visitar.",
    "False",
    "Los arreglos ordenados son más eficientes que las listas enlazadas para buscar elementos en la estructura",
    "True",
    "La inserción en un montículo tiene complejidad O(log n) en el peor de los casos, ya que debemos asegurarnos de mantener la propiedad del montículo al acomodar los elementos",
    "True",
    "La complejidad espacial de un árbol B es O(n log n)",
    "False",
    "Describa cómo se puede utilizar un conjunto o mapa para verificar si una lista tiene elementos duplicados.",
    "primero deberiamos crear un mapa vacio, luego debemos recorrer la lista pasando por todos sus elementos, e ir verificando si dicho elemento ya se encuentra en el mapa. si el elemento ya se encuentra en el mapa siginifica que es repetido y se determina que la lista tiene elementos duplicados. si no se encuentra en el mapa dicho elemento se agrega al mapa y se sigue recorriendo la lista. si terminamos de recorrer la lista significa que no hay elementos repetidos.",
    "Considere que tenemos un mapa de países, donde cada país tiene una lista de sus ciudades y cada ciudad tiene su población. ¿Cómo podría implementar una función para encontrar el país con la mayor población total?",
    "necesitaremos variables auxiliares, una que almacene la mayor poblacion en numeros y otra que almacene el pais con mayor poblacion.\n\nse recorre todos los paises en el mapa, para cada lista de ciudades por pais ir sumando su total y la almacenamos en la variable de poblacionActual.\n\nluego comparqmos poblacion poblacionActual con poblacionMayor y si la primera es mayor, se actualiza poblacionMayor con los datos de poblacion actual y mayorPais se le asigna el nombre del pais correspondiente.\n\nrealizar los pasos anteriores hasta terminar de recorrer el mapa y al final se obtendran los datos deseados en las variables auxiliares que creamos",
    "Diseña un algoritmo que permita verificar si un grafo es un árbol utilizando DFS o BFS.",
    "primero iniciamos en el primer nodo y lo marcamos como visitado. luego realizamos una busqueda en profundidad desde el inicial nodo por todos sus nodos adyacentes.\n\nmientras vayamos recorriendo, vamos teniendo un registro de los nodos visitados, si en algun momento pasamos por un nodo ya visitado significa que estamos en un grafo y no en un arbol.\n\nsi al finalizar de recorrer este grafo encontramos que todos los nodos han sido visitados es decir que efectivamente es un arbol."
],[
    "FLORES COLOANE",
    "MARCELO BENJAMIN",
    "marcelo.flores.c@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:46",
    "19 de mayo de 2023  15:15",
    "29 minutos 28 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos con la misma prioridad se procesan en orden de llegada",
    "Verdadero",
    "El árbol B\/B+ es útil para la implementación de algoritmos de búsqueda en grafos, ya que permite una rápida búsqueda de nodos y aristas",
    "Verdadero",
    "Se puede usar grafos para modelar redes de transporte, como el tráfico de carreteras o el transporte aéreo, ya que los grafos permiten representar la estructura de las conexiones y las relaciones entre ellas",
    "Verdadero",
    "En un montículo binario, la búsqueda de un elemento se realiza en tiempo constante",
    "Falso",
    "La operación de búsqueda en un árbol B+ implica recorrer todos los nodos hoja del árbol hasta encontrar el valor deseado",
    "Falso",
    "La búsqueda en anchura es una buena opción para grafos con una profundidad desconocida.",
    "Verdadero",
    "A diferencia de los arreglos ordenados, las tablas hash pueden tener un tiempo de acceso constante para la búsqueda de elementos",
    "Verdadero",
    "La búsqueda de un elemento en un montículo tiene complejidad O(n)",
    "Verdadero",
    "Un árbol B+ tiene una altura de entre 2 y 5 niveles.",
    "Falso",
    "Teniendo un mapa de estudiantes donde la clave es el número de matrícula y el valor es la nota final. ¿Cómo podrías calcular la nota promedio de todos los estudiantes?",
    "Primero habría que recorrer el mapa e ir sumando el valor que en este caso seria la nota final, al final de el algoritmo habría que simplemente dividir el resultado final por la cantidad de estudiantes que hay en el mapa, que se podría ocupar un contador cada vez que se agregue una nota final.",
    "Considere que tenemos un mapa de estudiantes, donde cada estudiante tiene una lista de cursos y las notas obtenidas en cada curso. ¿Cómo podría implementar una función para encontrar el curso en el que los estudiantes tienen el promedio de notas más bajo?",
    "Primero hay que recorrer el mapa e ir por la lista de cada curso para tener la nota obtenida e ir sumando cada nota de esa lista que seria el total de notas obtenidas en ese curso y luego dividirla en el tamaño de la lista. Esto hacerlo con cada curso, luego al obtener el promedio de nota del estudiante en cada curso, volver a recorrer el mapa e ir a la lista con el primer curso sacar esa nota promedio e ir al siguiente estudiante comprobar si esta en ese curso, en caso en el que este sumar las notas promedio y así con cada estudiante del mapa y luego dividirlo con un contador que se ira sumando en caso de encontrar que un estudiante tiene el mismo curso que el primer estudiante revisado. Hacer esto con cada curso encontrado al momento de recorrer el mapa y almacenarlo en un arreglo ordenado y así se podrá encontrar el curso con el promedio de nota mas bajo.",
    "Explique cómo podría implementar una cola con prioridad, usando 2 pilas. ¿Como realizaría inserciones y eliminaciones en la cola con prioridad?",
    "Iría llenando las pilas con menor prioridad en la pila 1 y con la de mayor prioridad en la pila 2 y al momento de insertar se veria que prioridad tiene si esta mas cercana a la de menor o mayor, ejemplo en caso de ser prioridad 2  se iría sacando las que están en prioridad 1 y guardandolas en la pila 2, luego guardar el elemento en la pila 1 y la pila 2 cambiaria, seria practicamente igual en la de eliminacion, seria jugar como un ping pong entre los elementos de las pilas."
],[
    "VILLEGAS MUÑOZ",
    "MATIAS ELISEO",
    "matias.villegas.m@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:25",
    "19 de mayo de 2023  14:44",
    "19 minutos 49 segundos",
    "Sin calificar aún",
    "Se puede utilizar colas con prioridad para acelerar el procesamiento de datos",
    "Verdadero",
    "El árbol B\/B+ es útil para la implementación de algoritmos de búsqueda en grafos, ya que permite una rápida búsqueda de nodos y aristas",
    "Verdadero",
    "Un grafo es útil cuando queremos optimizar el flujo de recursos en una red, como el suministro de energía o la distribución de agua, ya que los algoritmos de flujo en grafos pueden encontrar la ruta más eficiente para distribuir los recursos",
    "Verdadero",
    "Un montículo binario puede ser implementado utilizando un arreglo.",
    "Verdadero",
    "En un árbol B+, los nodos internos pueden contener datos además de las claves",
    "Falso",
    "La búsqueda en anchura utiliza una cola para almacenar los nodos a visitar.",
    "Verdadero",
    "Los arreglos ordenados son más eficientes que las listas enlazadas para buscar elementos en la estructura",
    "Verdadero",
    "La búsqueda de un elemento en un montículo tiene complejidad O(n)",
    "Verdadero",
    "La complejidad espacial de un árbol B es O(n log n)",
    "Falso",
    "Suponga que tiene un conjunto de operaciones a realizar, cada una con un tiempo de duración diferente. ¿Cómo podría usar una cola de prioridad para ordenar las operaciones de manera que se realicen primero las más cortas?",
    "Primero podriamos usar una cola de prioridad minima, lo que permite que ordenemos las distintas operacion segun el tiempo que se realicen, como en este caso piden el tiempo mas corto seria la primera operacion en realizarse",
    "Considere que tenemos un mapa de estudiantes, donde cada estudiante tiene una lista de asignaturas. Cada asignatura tiene una lista de calificaciones. ¿Cómo podría implementar una función para calcular el promedio general de cada estudiante?",
    "Primero la funcion crearia un mapa que seria el promedio general de cada estudiantes, para ello tendria que acceder a cada estudiante del mapa de estudiantes y sacar su lista de calificaciones y asignaturas, por cada iteracion sumaria las notas de cada asignatura del estudiante, por ejemplo cada iteracion seria la suma de calificaciones de la asignatura(mate,lenguaje,etc) y cuando salga de la iteracion tendriamos la suma total de cada estudiante por lo que faltaria dividir por el cantidad total de asignaturas y guardas en un promedio dentro del mapa auxiliar.",
    "Explique un algoritmo que permita calcular la profundidad de un árbol binario utilizando una pila. La profundidad de un árbol binario es la longitud del camino más largo desde la raíz hasta una hoja.",
    "Primero iniciazamos una pila y agregaríamos el nodo raíz del árbol binario, para después crear una variable profundidad en 0 y mientras que la pila no este vacía vemos si  la hoja del árbol binario es un nodo hoja, actualizaremos la profundidad  si la profundidad  es mayor a su nivel actual. peros si la hoja del árbol no es un nodo hoja, empujaremos los nodos hojas hijos si es que los tiene a la pila junto con sus niveles correspondientes  (nivel = nodoHoja + 1) y retornariamos la profundidad."
],[
    "HENRIQUEZ TAPIA",
    "PATRICIO ARTURO",
    "henriquezpatricio26@gmail.com",
    "Finalizado",
    "19 de mayo de 2023  08:23",
    "19 de mayo de 2023  08:40",
    "17 minutos 24 segundos",
    "Sin calificar aún",
    "Las colas con prioridad pueden ser utilizadas para la planificación de tareas en un sistema de gestión de proyectos",
    "Verdadero",
    "En un árbol B, todas las hojas se encuentran en el mismo nivel",
    "Falso",
    "Se puede usar grafos para modelar relaciones y conexiones entre elementos, como redes de transporte o redes sociales, ya que los grafos permiten representar de manera clara y visual la estructura de estas conexiones y facilitan el análisis y la toma de decisiones",
    "Verdadero",
    "Un montículo binario solo puede ser utilizado para elementos de tipo numérico, ya que la propiedad de ordenación se basa en la comparación de valores numéricos",
    "Falso",
    "La operación de inserción en un árbol B implica dividir un nodo si este ya está lleno y redistribuir las claves y los punteros de manera que el árbol siga cumpliendo con las propiedades del árbol B",
    "Verdadero",
    "La búsqueda en profundidad puede ser implementada de manera recursiva.",
    "Verdadero",
    "Las tablas hash son más eficientes que los arreglos y las listas enlazadas para buscar elementos en la estructura",
    "Falso",
    "El orden en que se ingresan los elementos en un montículo binario no afecta su complejidad temporal, ya que siempre se cumple la propiedad del montículo",
    "Verdadero",
    "La búsqueda en un árbol B tiene complejidad temporal O(n), donde n es el número de elementos en el árbol.",
    "Falso",
    "Tenemos una lista de personas con su nombre y país de origen. ¿Cómo podríamos agrupar a las personas por país utilizando un mapa?",
    "Primero, nos preguntamos que país queremos guardar en el mapa, para luego empezar a recorrer cada uno de los elementos, donde cuando los encuentre, los borrará de la lista para posteriormente mejorar la búsqueda de usuarios que cumplan con el requisito y los ingresará a una nueva lista, exclusiva del país, donde dicha lista, será ingresada a un mapa, donde, en el mapa, el primer país que escogimos será ingresado primero y así sucesivamente.",
    "Considere que tenemos un mapa de estudiantes, donde cada estudiante tiene una lista de asignaturas. Cada asignatura tiene una lista de calificaciones. ¿Cómo podría implementar una función para calcular el promedio general de cada estudiante?",
    "Primero hay que ingresar a cada lista de notas por asignatura, de cada estudiante, donde, además, se creará una nueva lista, esta lista tendrá el promedio por asignatura en el mismo orden que se encuentra en la lista de asignaturas del estudiante, entonces, luego se calcula el promedio de la asignatura y la ingreso a la nueva lista que se creo por estudiante, donde se encuentra cada promedio, así sucesivamente hasta que termine las asignaturas, donde, una vez que termine con estas, promediará los promedios por asignaturas y las ingresará al final de la lista, o al inicio también, para que tenga un mejor acceso a esta nota promedial.",
    "Dado un laberinto representado como una matriz de celdas, describe un algoritmo que encuentre un camino desde la entrada hasta la salida utilizando una pila.",
    "La pila en cuestión serán todas las direcciones que tome el usuario, por ejemplo, el algoritmo entra por el entrada, después empieza a tomar decisiones, siempre de izquierda a derecha, donde, si toma una decisión equivocada eliminará la decisión hecha y retornará al punto donde tomó la decisión, entonces, sigamos con el ejemplo, el algoritmo no encontró más camino por la izquierda, por lo que deberá seguir por los otros caminos, descartando por completo la izquierda, y así sucesivamente hasta encontrar el camino correcto, si por algún motivo ninguno de los caminos que tomó, de izquierda a derecha (supongo que también considera arriba), no llevan a ningún lado, vuelve más atrás, donde repite el mismo proceso, eliminando y agregando continuamente las decisiones."
],[
    "CISTERNAS CISTERNAS",
    "ISIDORA VALENTINA",
    "isi.cisternass@gmail.com",
    "Finalizado",
    "18 de mayo de 2023  12:37",
    "18 de mayo de 2023  12:52",
    "15 minutos 17 segundos",
    "Sin calificar aún",
    "Las colas con prioridad son útiles para procesar tareas en orden de importancia",
    "Verdadero",
    "El árbol B\/B+ es útil para la implementación de estructuras de datos en memoria principal, ya que minimiza el uso de memoria",
    "Falso",
    "Se puede usar grafos para analizar redes complejas, como la propagación de enfermedades o la interconexión de sistemas informáticos, ya que los grafos permiten modelar las interacciones entre los elementos y estudiar cómo se propagan los efectos a través de la red",
    "Verdadero",
    "Podemos usar un montículo binario para encontrar el k-ésimo elemento más pequeño de una lista: construimos un montículo a partir de la lista original y luego eliminamos los k-1 elementos más pequeños de manera secuencial. El elemento siguiente es el k-ésimo elemento más pequeño",
    "Falso",
    "La operación de inserción en un árbol B implica dividir un nodo si este ya está lleno y redistribuir las claves y los punteros de manera que el árbol siga cumpliendo con las propiedades del árbol B",
    "Verdadero",
    "La búsqueda en profundidad consume más memoria que la búsqueda en anchura en grafos anchos.",
    "Falso",
    "A diferencia de los arreglos ordenados, las tablas hash pueden tener un tiempo de acceso constante para la búsqueda de elementos",
    "Verdadero",
    "La complejidad temporal de la operación de búsqueda en un montículo binario es O(log n), ya que se debe descender por el árbol",
    "Verdadero",
    "La complejidad temporal de la búsqueda en un árbol B es O(log n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "Tenemos una lista de productos con su precio y categoría. ¿Cómo podríamos calcular el precio promedio por categoría usando un mapa?",
    "Se crea un mapa en donde las claves serían las categorias y en los valores se irían acumulando la suma de los precios y la cantidad de productos por categoria. Al terminar de rellenar el mapa se deberá ir calculando el precio promedio por categoria gracias a que tenemos la suma de precios totales y la cantidad de productos por categoria. Finalmente se almacena en el mismo mapa, para asi poder acceder a través del nombre de la categoría.",
    "Supongamos que tenemos un mapa de autores, donde cada autor tiene una lista de libros que ha escrito. Cada libro incluye título, género y calificación promedio. ¿Cómo implementarías una función para calcular la calificación promedio de los libros del género de aventuras?",
    "Podemos crear una función que vaya recorriendo el mapa y que vaya guardando solo las calificaciones de los libros del género de aventuras (sumandolas) junto con un contador para saber cuantos libros de aventura hay. Cuando ya se haya recorrido el mapa por completo, se debe calcular la calificacion promedio con las sumas de las calificaciones y las cantidades de libros de aventuras que hay.",
    "Cree un algoritmo que, usando una pila, verifique si una secuencia de llaves y corchetes está correctamente anidada. Por ejemplo, \"{[()]}\" y \"{}\" están correctamente anidados, mientras que \"{[(])}\" y \"{[}\" no lo están.",
    "Cuando se recorra la secuencia, si se reconoce una entrada de llave y\/o corchete (\"{[(\") este se debe ingresar a la pila. Luego, se empieza un ciclo en donde si se reconoce un cierre de llave y\/o corchete se recorra la pila para verificar de que exista algún \"abre\" corchete y\/o llave (\"{[(\") si es así, se elimina de la pila y se repite el proceso las veces que sea necesario. En el caso de que se reconozca un cierre corchete y\/o llave y no exista el símbolo correspondiente en la pila (\"{[(\"), se retorna false ya que no está la secuencia completa. \n\nSi se itera y encontró siempre las secuencias, se retorna true."
],[
    "LARA ARCE",
    "JOSE IGNACIO",
    "jolara.saic@gmail.com",
    "Finalizado",
    "19 de mayo de 2023  14:25",
    "19 de mayo de 2023  14:55",
    "30 minutos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos se eliminan en función de su orden de llegada",
    "Falso",
    "El árbol B\/B+ es útil para la implementación de bases de datos, ya que permite una rápida recuperación de datos y una fácil actualización de los mismos",
    "Verdadero",
    "Un grafo es útil cuando queremos analizar patrones de tráfico en internet, ya que los grafos pueden representar los flujos de datos entre diferentes sistemas y los nodos críticos en la red",
    "Verdadero",
    "Un montículo binario es una estructura de datos inmutable, es decir, una vez que se crea un montículo, no se pueden realizar modificaciones en su contenido",
    "Falso",
    "En un árbol B, el número de claves en cada nodo es fijo",
    "Verdadero",
    "La búsqueda en profundidad puede ser implementada de manera recursiva.",
    "Verdadero",
    "A diferencia de la tabla hash, los árboles B+ pueden trabajar con grandes volúmenes de datos.",
    "Falso",
    "El acceso al elemento mínimo en un montículo binario de mínimos tiene complejidad temporal O(1), ya que este se encuentra en la raíz del árbol",
    "Verdadero",
    "La complejidad espacial de un árbol B+ es mayor que la de un árbol B debido a que los nodos internos almacenan más claves.",
    "Verdadero",
    "Considere un conjunto de estudiantes con sus respectivas calificaciones. ¿Cómo podría usar una cola de prioridad para identificar rápidamente a los 5 estudiantes con las calificaciones más altas?",
    "Se guardan los estudiantes en la estructura (montículo binario por mínimos por ejemplo), y dependiendo de la nota que tengan tienen más o menos prioridad, si queremos guardar a los 5 mejores, simplemente los que tengan un 7.0 de calificación tendrán prioridad 1, (la más alta) mientras más baja la nota, menos prioridad tendrán, por lo que para identificar los 5 mejores recorremos la cola y mostramos los 5 elementos con la prioridad más alta.",
    "Tenemos un mapa de productos, donde cada producto tiene una lista de precios de diferentes proveedores. ¿Cómo podría implementar una función para encontrar el proveedor más barato para cada producto?",
    "Primero accedemos al mapa y al bucket del producto, creamos una variable que almacene el precio mínimo y una lista que almacene el mínimo de cada producto, luego recorremos la lista de precios de los diferentes proveedores, y las comparamos hasta el final de la lista, luego con la variable con el precio mínimo, la asignamos a la lista y así con cada producto hasta recorrer el mapa completo de productos.",
    "Cree un algoritmo que, usando una pila, verifique si una secuencia de llaves y corchetes está correctamente anidada. Por ejemplo, \"{[()]}\" y \"{}\" están correctamente anidados, mientras que \"{[(])}\" y \"{[}\" no lo están.",
    "Básicamente primero podemos crear un struct de tipo llave-corchete que almacene el caracter (char) de la llave o corchete, y un dato booleano (bool) que diga si este fue anidado o no.\n\nluego creamos una función llamada, por ejemplo, \"bool anidacion(char *secuenciaLlavesCorchete)\" que analice la secuencia y determine si está bien anidada o no y que retorne un valor de verdad.\n\nCreamos una pila que almacene cada dato tipo llave-corchete, hacemos uso de la pila porque primero deben estar bien anidados los corchetes o llaves de más adentro y luego los de más afuera.\n\nLuego de almacenar todas las llaves o corchetes de la secuencia en la pila, creamos una pila auxiliar y la recorremos en un while hasta que el siguiente dato de la pila sea NULL\n\nMientras recorremos partemos desde la mitad del largo de la secuencia, y verificamos si cada llave o corchete tiene su contraparte para anidar, si es que esta anidada completa,ente returna true"
],[
    "ERAZO MUÑOZ",
    "LUCAS ALBERTO",
    "lucazerazo77@gmail.com",
    "Finalizado",
    "19 de mayo de 2023  15:02",
    "19 de mayo de 2023  15:30",
    "28 minutos 11 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos con la misma prioridad se procesan en orden de llegada",
    "Verdadero",
    "Los árboles B+ son utilizados para mejorar el rendimiento de la búsqueda secuencial en disco",
    "Verdadero",
    "Se puede usar grafos para analizar redes complejas, como la propagación de enfermedades o la interconexión de sistemas informáticos, ya que los grafos permiten modelar las interacciones entre los elementos y estudiar cómo se propagan los efectos a través de la red",
    "Verdadero",
    "Un montículo binario puede ser implementado utilizando un arreglo.",
    "Verdadero",
    "La operación de inserción en un árbol B implica dividir un nodo si este ya está lleno y redistribuir las claves y los punteros de manera que el árbol siga cumpliendo con las propiedades del árbol B",
    "Verdadero",
    "La búsqueda en profundidad es más eficiente que la búsqueda en anchura en grafos profundos.",
    "Falso",
    "Las listas enlazadas son más eficientes que los arreglos para insertar o eliminar elementos en posiciones aleatorias de la estructura",
    "Falso",
    "Un montículo binario puede tener múltiples elementos con el mismo valor",
    "Falso",
    "La complejidad espacial de un árbol B+ es mayor que la de un árbol B debido a que los nodos internos almacenan más claves.",
    "Falso",
    "Considere un conjunto de estudiantes con sus respectivas calificaciones. ¿Cómo podría usar una cola de prioridad para identificar rápidamente a los 5 estudiantes con las calificaciones más altas?",
    "se hará una struct que tendrá el estudiantes y su calificación , serán insertados en un montículo que su capacidad será 5 y seguirá las reglas de estar ordenado de mayor a menor, en la ultima posición del montículo estará la nota mas baja de las 5 mas altas, y cuando se compare otro estudiante si su calificación es mayor q la ultima del montículo, se cambia el top por la ultima posicion,se hace un pop y se inserta el nuevo estudiante con su calificación, el montículo se volverá a ordenar, así estará las 5 notas mas altas ",
    "Tenemos un mapa de libros, donde cada libro tiene una lista de reseñas de usuarios. ¿Cómo podríamos calcular el número de usuarios que han calificado el libro \"Cien años de soledad\" con 5 estrellas?",
    "la clave del mapa serán los nombres de los libros , se accederá al primero del mapa con firstmap,y se recorrera el mapa con nextmap hasta encontrar la clave \"cien años de soledad\", el valor que tendra el mapa será la lista con el usuario y la calificación de estrellas al libro, se iniciara un contador en cero y se recorrerá la lista hasta que el current sea nulo, y en cada nodo que la calificación sea 5 se aumentara en 1 el contador",
    "Explica un algoritmo para implementar una cola utilizando dos pilas.",
    "para poder implementar la cola con 2 pilas, la primera pila será llenada con los datos insertado en donde el ultimo estará en el top y abajo estará los que van antes, entonces a la pila se le hará un pop y antes de esto será guardado en un auxiliar para luego hacer un push en la 2da pila que estará vacía , así los elementos de la primera pila estarán el orden alreves que la primera, así los elementos serán procesados por el respectivo orden de llegada"
],[
    "PEREZ MIRANDA",
    "EDUARDO ANDRES",
    "eduardo.perez.m@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:54",
    "19 de mayo de 2023  15:21",
    "26 minutos 36 segundos",
    "Sin calificar aún",
    "Se puede usar colas con prioridad para almacenar los nodos en un algoritmo de búsqueda en grafos",
    "Verdadero",
    "Los árboles B son similares a los árboles AVL en términos de estructura",
    "Verdadero",
    "Un grafo es útil cuando queremos analizar redes de comunicaciones, ya que los grafos pueden ser utilizados para identificar nodos críticos y patrones de comunicación",
    "Verdadero",
    "Un montículo binario puede ser implementado utilizando un arreglo.",
    "Verdadero",
    "En un árbol B+, los datos están organizados en orden ascendente en cada hoja y las hojas están enlazadas",
    "Verdadero",
    "La búsqueda en anchura encuentra la solución óptima para problemas de camino más corto.",
    "Verdadero",
    "Los árboles B son más eficientes que los arreglos y las listas enlazadas para realizar búsquedas, inserciones y eliminaciones en grandes conjuntos de datos",
    "Verdadero",
    "La complejidad espacial de un montículo binario es O(n), ya que todos los elementos se almacenan en el árbol",
    "Verdadero",
    "La inserción en un árbol B+ tiene complejidad temporal O(log n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "Considera que tienes un mapa donde la clave es el nombre de una película y el valor es una lista de actores. ¿Cómo implementarías una función para encontrar todas las películas en las que trabaja un actor determinado?",
    "Se haría una búsqueda en todas las listas adyacentes a cada elemento del mapa. Cada vez que se encuentra el nombre del actor en alguna lista adyacente, el nombre de la película es ingresado a una lista auxiliar y se deja de buscar en esa lista adyacente para seguir a la siguiente lista adyacente (de la siguiente película).",
    "Tenemos un mapa de productos, donde cada producto tiene una lista de precios de diferentes proveedores. ¿Cómo podría implementar una función para encontrar el proveedor más barato para cada producto?",
    "Se podría implementar lo pedido siguiendo los siguientes pasos:\n1. Se crea un nuevo mapa donde la clave será el nombre del producto y el valor será el nombre de un proveedor, \"mapaProveedores\". Además, se crea una variable auxiliar llamada \"precioMasBarato\", una clave auxiliar \"claveAux\", y un proveedorAuxiliar \"provAux\"\n2. Se busca al primer elemento del mapa 1 (mapa dado).\n\n3. Se guarda la clave del elemento en \"claveAux\" (nombre del producto).\n\n4. Se accede a la lista adyacente a ese elemento.\n\n5. Se le asigna a precioMasBarato el valor del primer precio del primer proveedor y el primer proveedor será asignado a provAux. \n\n6. Luego si en la lista adyacente al primer elemento del mapa 1, se encuentra que existe un precio más barato a \"precioMasBarato\": Se le asignará ese precio a la variable y se le asignará ese proveedor a provAux.\n\n7. Luego de recorrer completamente la lista adyacente, se habrá encontrado el precio efectivamente más barato y su respectivo proveedor almacenado ya en \"provAux\". \n\n8. Se accede al siguiente elemento del mapa 1.\n\n9. Se repiten los pasos del 3 al 8, hasta que el siguiente elemento del mapa 1 sea NULL (ya se recorrió todo el mapa).",
    "Describe el algoritmo de búsqueda en anchura (BFS, por sus siglas en inglés) en un grafo, utilizando una cola.",
    "Se describe al algoritmo de búsqueda en anchura con los siguientes pasos:\n\n1. Comenzar desde un nodo y agregarlo a la cola.\n\n2. Mientras la cola no esté vacía:\n\n- Extraer nodo frontal cola.\n\n- Marcar el nodo como visitado.\n\n- Agregar todos los nodos vecinos no visitados del nodo actual a la cola.\n\n(Con el paso 2 se habría recorrido un nivel del grafo).\n\n3. Repetir el paso 2 hasta que la cola esté vacía. \n\n(Luego de terminar el paso 3 se habría recorrido todo el grafo)."
],[
    "CORDERO PONCE",
    "ADOLFO MATIAS",
    "adolfocorderoponce@gmail.com",
    "Finalizado",
    "19 de mayo de 2023  14:49",
    "19 de mayo de 2023  15:16",
    "26 minutos 52 segundos",
    "Sin calificar aún",
    "Se puede usar colas con prioridad para almacenar los nodos en un algoritmo de búsqueda en grafos",
    "Verdadero",
    "El árbol B\/B+ es útil para aplicaciones en las que las claves cambian con frecuencia, ya que es fácil actualizar los nodos",
    "Falso",
    "Un grafo es útil cuando queremos encontrar la ruta más corta entre dos nodos, ya que los algoritmos de búsqueda de caminos en grafos son muy eficientes",
    "Verdadero",
    "En un montículo binario, todos los niveles del árbol excepto posiblemente el último están completamente llenos, y los nodos del último nivel se llenan de izquierda a derecha",
    "Verdadero",
    "En un árbol B+, los nodos internos pueden contener datos además de las claves",
    "Falso",
    "La búsqueda en profundidad consume más memoria que la búsqueda en anchura en grafos anchos.",
    "Falso",
    "A diferencia de los montículos, los arreglos ordenados mantienen la posición relativa de los elementos",
    "Verdadero",
    "La inserción en un montículo tiene complejidad O(log n) en el peor de los casos, ya que debemos asegurarnos de mantener la propiedad del montículo al acomodar los elementos",
    "Verdadero",
    "La complejidad temporal de la inserción en un árbol B es O(n) debido a que se deben realizar varias divisiones y fusiones de nodos",
    "Falso",
    "Considere un conjunto de estudiantes con sus respectivas calificaciones. ¿Cómo podría usar una cola de prioridad para identificar rápidamente a los 5 estudiantes con las calificaciones más altas?",
    "Se implementa un cola de prioridad con los datos de los alumnos \n\nSe recorre y se guardan los datos en una lista ordenadas según calificación en orden descendente.\n\nSe recorre la lista (firstList y nextList). ",
    "Suponga que tiene un mapa de restaurantes, donde cada restaurante tiene una lista de platos en su menú. ¿Cómo podría imprimir todos los restaurantes que tienen \"pasta carbonara\" en su menú?",
    "Se recorre el mapa con los datos de los restaurantes (firstMap, nextMap)\n\nPor cada dato, se recorre la lista que almacena el menú.\n\nPor cada coincidencia entre \"pasta carbonara\" y el dato de la lista (strcmp() == 0), se imprime el key del dato del mapa actual y se retorna.",
    "Describe un algoritmo que verifique si un grafo dirigido contiene un ciclo, utilizando una pila.",
    "Se implementa una pila, donde se almacenarán en orden los datos del grafo, (datos no visitados).\n\nSe recorre la pila, donde por cada dato, se verificará su existencia previa en alguno de los otros nodos de la pila.\nSi se encuentra, el grafo contiene un ciclo, sino, es acíclico."
],[
    "AVILA YAÑEZ",
    "IGNACIO ENRIQUE",
    "ignacio.avila215@gmail.com",
    "Finalizado",
    "18 de mayo de 2023  12:21",
    "18 de mayo de 2023  12:48",
    "27 minutos 13 segundos",
    "Sin calificar aún",
    "Las colas con prioridad son útiles para procesar tareas en orden de importancia",
    "Verdadero",
    "Los árboles B son similares a los árboles AVL en términos de estructura",
    "Falso",
    "Se puede usar grafos para modelar relaciones y conexiones entre elementos, como redes de transporte o redes sociales, ya que los grafos permiten representar de manera clara y visual la estructura de estas conexiones y facilitan el análisis y la toma de decisiones",
    "Verdadero",
    "En un montículo binario, todos los niveles del árbol excepto posiblemente el último están completamente llenos, y los nodos del último nivel se llenan de izquierda a derecha",
    "Verdadero",
    "La operación de búsqueda en un árbol B+ implica recorrer todos los nodos hoja del árbol hasta encontrar el valor deseado",
    "Falso",
    "La búsqueda en profundidad es más eficiente que la búsqueda en anchura en grafos profundos.",
    "Verdadero",
    "A diferencia de los montículos, los arreglos ordenados mantienen la posición relativa de los elementos",
    "Verdadero",
    "La búsqueda de un elemento en un montículo tiene complejidad O(n)",
    "Falso",
    "La inserción en un árbol B+ tiene complejidad temporal O(log n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "Tenemos una lista de productos con su precio y categoría. ¿Cómo podríamos calcular el precio promedio por categoría usando un mapa?",
    "Se podría calcular recorriendo el mapa, y comprobando por cada producto si corresponde a la categoría buscada. Sumamos el valor del precio si corresponde a la categoría buscada y sumamos 1 a un contador que se inicializa en 0 para saber cuantos productos fueron sumados. Por último dividimos la suma de los precios que corresponden a la categoría buscada por el contador para sacar el promedio.",
    "Supongamos que tenemos un mapa de usuarios de un sitio web, donde cada usuario tiene una lista de productos que ha comprado. ¿Cómo podría implementar una función para encontrar el producto más comprado?",
    "Para cada usuario almacenamos el tipo de producto que ha comprado y lo agregamos a una lista donde se va a ir sumando dependiendo del tipo de producto. Por último recorremos la lista y el tipo de producto que tenga más cantidad es el más comprado.",
    "Explique un algoritmo que permita calcular la profundidad de un árbol binario utilizando una pila. La profundidad de un árbol binario es la longitud del camino más largo desde la raíz hasta una hoja.",
    "Primero recorremos el árbol partiendo desde la raíz y vamos almacenando la cantidad de arcos en una pila. Luego creamos una variable auxiliar donde vamos a almacenar el dato más grande y vamos comparando a medida que eliminamos los datos de la pila."
],[
    "CRUZ POMAR",
    "SEBASTIAN EMILIO",
    "sebastiancruzpomar@gmail.com",
    "Finalizado",
    "18 de mayo de 2023  12:17",
    "18 de mayo de 2023  12:32",
    "14 minutos 50 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos con la misma prioridad son procesados en orden aleatorio",
    "Falso",
    "Los árboles B pueden ser utilizados para implementar índices en bases de datos",
    "Verdadero",
    "Se puede usar grafos para modelar sistemas de recomendación, como en aplicaciones de comercio electrónico o de películas, ya que los grafos pueden representar las preferencias de los usuarios y las relaciones entre productos o películas",
    "Verdadero",
    "Un montículo binario es una estructura de datos que permite mantener una colección de elementos ordenados en función de su valor, con una complejidad de tiempo logarítmica para las operaciones de inserción, eliminación y búsqueda",
    "Verdadero",
    "En un árbol B, cada nivel del árbol se llena por completo antes de agregar un nuevo nivel",
    "Verdadero",
    "La búsqueda en anchura utiliza una cola para almacenar los nodos a visitar.",
    "Verdadero",
    "Los arreglos ordenados son más eficientes que las listas enlazadas para buscar elementos en la estructura",
    "Verdadero",
    "El acceso al elemento mínimo en un montículo binario de máximos tiene complejidad O(log n), ya que se debe descender por el árbol hasta llegar al nodo hoja más a la izquierda",
    "Verdadero",
    "La complejidad temporal de la inserción en un árbol B es O(1)",
    "Falso",
    "¿Cómo podríamos implementar una función que tome una lista de palabras y retorne las palabras ordenadas de acuerdo a su longitud? (use TDAs y no algoritmos de ordenamiento)",
    "se podría implementar con una cola por prioridad siendo la prioridad la cantidad de letras, ocupando la funcion strlen(), así la que tenga mayor cantidad de letras seria la primera en retornarse. ",
    "Tenemos un mapa de empleados, cada uno con una lista de proyectos en los que han trabajado y el tiempo que dedicaron a cada uno. ¿Cómo podría implementar una función para encontrar el empleado que ha dedicado más tiempo a los proyectos?",
    "se podria hacer recorriendo todo el mapa y guardando la suma del tiempo empleado en una lista junto con su nombre, despúes al recorrer la lista guardar la posicion en la que se encuentra el que haya empleado mas tiempo y hacer un return de ese nombre.",
    "Diseña un algoritmo que permita verificar si un grafo es un árbol utilizando DFS o BFS.",
    "se podria verificar si es un arbol con una busqueda por anchura y ver si estan ordenados de la forma de un arbol, es decir, que al lado izquierdo esten los menores siempre y no haya un valor mayor al anterior hasta pasar al lado derecho de los nodos"
],[
    "VILLARROEL GALLEGUILLOS",
    "FELIPE ALEJANDRO",
    "felipe.villarroel.g01@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  08:30",
    "19 de mayo de 2023  08:37",
    "7 minutos 9 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos con la misma prioridad se procesan en orden de llegada",
    "Verdadero",
    "Los árboles B\/B+ se utilizan para mejorar la eficiencia de las operaciones de lectura y escritura en disco en bases de datos",
    "Verdadero",
    "Se puede usar grafos para modelar relaciones y conexiones entre elementos, como redes de transporte o redes sociales, ya que los grafos permiten representar de manera clara y visual la estructura de estas conexiones y facilitan el análisis y la toma de decisiones",
    "Verdadero",
    "Un montículo binario es una estructura de datos inmutable, es decir, una vez que se crea un montículo, no se pueden realizar modificaciones en su contenido",
    "Falso",
    "La operación de búsqueda en un árbol B+ implica recorrer todos los nodos hoja del árbol hasta encontrar el valor deseado",
    "Falso",
    "La búsqueda en profundidad utiliza una cola para almacenar los nodos a visitar.",
    "Falso",
    "Los arreglos ordenados son más eficientes que las listas enlazadas para buscar elementos en la estructura",
    "Verdadero",
    "Un montículo binario puede tener múltiples elementos con el mismo valor",
    "Verdadero",
    "La complejidad espacial de un árbol B+ es mayor que la de un árbol B debido a que los nodos internos almacenan más claves.",
    "Verdadero",
    "Suponga que tiene un conjunto de operaciones a realizar, cada una con un tiempo de duración diferente. ¿Cómo podría usar una cola de prioridad para ordenar las operaciones de manera que se realicen primero las más cortas?",
    "Se podria implementar un monticulo binario de minimos, en el cual el valor para ordenar los datos sería el tiempo de duracion de cada tarea, de esta manera quedarían ordenadas de la mas corta a la mas larga",
    "Supongamos que tenemos un mapa de estudiantes donde la clave es el ID del estudiante y el valor es una lista de asignaturas en las que se ha inscrito. ¿Cómo implementarías una función para eliminar una asignatura?",
    "Primero buscaria el ID del estudiante en el mapa, luego crearía una lista nueva e iteraria sobre la lista anterior agregando todas las tareas que no coincidan con la tarea que se quiere elimar a la nueva lista, finalmente reemplazaría la lista antigua con la nueva en el valor del dato en el mapa.",
    "Describe un algoritmo de Breadth-First Search (BFS) para encontrar el camino más corto entre un nodo A y un nodo B (la distancia entre par de nodos conectados es 1).",
    "Iterar sobre los nodos adyacentes del nodo A, guardar todos los nodos que tengan distancia 1 y conecten con un nodo que tenga relacion con el nodo B"
],[
    "FIGUEROA GALLARDO",
    "PATRICIO JAVIER",
    "patricio.figueroa.g@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:46",
    "19 de mayo de 2023  15:03",
    "16 minutos 54 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos con la misma prioridad son procesados en orden aleatorio",
    "Falso",
    "En un árbol B, la inserción siempre se realiza en las hojas. (Aunque luego es posible que el nuevo dato suba a causa de una división de nodos)",
    "Verdadero",
    "Se puede usar grafos para modelar redes de transporte, como el tráfico de carreteras o el transporte aéreo, ya que los grafos permiten representar la estructura de las conexiones y las relaciones entre ellas",
    "Verdadero",
    "En un montículo binario, la inserción de un nuevo elemento siempre se realiza en la hoja más profunda del árbol, y luego se reordena el árbol hacia arriba para mantener la propiedad de ordenación",
    "Falso",
    "En un árbol B+, las hojas contienen todos los datos almacenados en el árbol, mientras que los nodos internos solo contienen claves para dividir los datos en subárboles",
    "Verdadero",
    "La búsqueda en profundidad puede ser implementada de manera recursiva.",
    "Verdadero",
    "Los arreglos ordenados son más eficientes que las listas enlazadas para buscar elementos en la estructura",
    "Verdadero",
    "La complejidad espacial de un montículo binario es O(n), ya que todos los elementos se almacenan en el árbol",
    "Verdadero",
    "La complejidad temporal de la búsqueda en un árbol B es O(log n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "Suponga que tiene un conjunto de operaciones a realizar, cada una con un tiempo de duración diferente. ¿Cómo podría usar una cola de prioridad para ordenar las operaciones de manera que se realicen primero las más cortas?",
    "Se podría usar la implementación de montículo mínimo, en este caso, la prioridad sería la duración de cada tarea, mientras que el dato sería la tarea en sí; de esta forma se ordenan los procesos de forma que se realizan primero las más cortas. Para realizar las acciones, se guarda el top del montículo y se realiza la acción, luego se elimina la raíz del montículo, esto hará que la siguiente tarea a realizar sea las más corta en tiempo en el conjunto de tareas no realizadas; se repite este proceso hasta que el montículo esté vacío y se hayan procesado todas las tareas.",
    "Tenemos un mapa de libros, donde cada libro tiene una lista de reseñas de usuarios. ¿Cómo podríamos calcular el número de usuarios que han calificado el libro \"Cien años de soledad\" con 5 estrellas?",
    "Si el mapa utiliza de clave el nombre del libro, entonces se busca en el mapa el dato con clave \"Cien años de soledad\", dado que es el nombre del libro a buscar, luego revisamos las calificaciones de los usuarios y usamos un contador que sume 1 cada vez que un usuario realizó una crítica con 5 estrellas, esto se realiza hasta recorrer toda la lista de reseñas, de esta forma se obtiene el total de usuarios que realizaron una reseña de 5 estrellas al libro \"Cien años de soledad\".",
    "Explica un algoritmo para implementar una cola utilizando dos pilas.",
    "Dado que la pila almacena los datos de llegada en orden contrario a la cola, se utilizará una pila principal y otra auxiliar; para llenar la cola , se insertan todos los datos en la pila auxiliar, y dado que están en orden inverso a la cola, se insertan los datos de la pila auxiliar en la pila principal, de esta forma, el top de la pila principal será el primer dato ingresado por el usuario, esto dado que es el último dato de la pila auxiliar; de esta forma, se conserva el orden necesario para utilizar una cola. "
],[
    "MEDIANO LARENAS",
    "VICENTE ANDRES",
    "vicente.mediano.l@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:25",
    "19 de mayo de 2023  14:47",
    "22 minutos 13 segundos",
    "Sin calificar aún",
    "Las colas con prioridad pueden ser utilizadas para la planificación de tareas en un sistema de gestión de proyectos",
    "Verdadero",
    "El árbol B\/B+ es útil para la gestión de archivos, ya que permite una rápida recuperación y ordenamiento de los registros",
    "Verdadero",
    "Se puede usar grafos para modelar relaciones entre entidades, ya que los grafos permiten representar de forma clara y concisa las relaciones complejas entre elementos",
    "Verdadero",
    "Un montículo binario se puede utilizar para implementar una cola de prioridad",
    "Verdadero",
    "En un árbol B, la operación de búsqueda tiene una complejidad de tiempo constante, independientemente del número de elementos almacenados en el árbol",
    "Falso",
    "La búsqueda en anchura encuentra la solución óptima para problemas de camino más corto.",
    "Falso",
    "Los árboles B son ideales para el acceso secuencial de datos",
    "Verdadero",
    "El acceso al elemento mínimo en un montículo binario de mínimos tiene complejidad temporal O(1), ya que este se encuentra en la raíz del árbol",
    "Verdadero",
    "La complejidad temporal de la inserción en un árbol B es O(1)",
    "Falso",
    "¿Cómo podríamos implementar una función que tome una lista de palabras y retorne las palabras ordenadas de acuerdo a su longitud? (use TDAs y no algoritmos de ordenamiento)",
    "Se podria usar un arbol binario donde cada nodo del arbol sea la palabra, ademas de tener un bool o contador que verifique que esta palabra no exista en otra parte del arbol. Cada vez que se inserte una palabra nueva, es decir, un nuevo nodo, se compare con la palabra anterior insertada y las demas que existan en el arbol, y se ordene de forma indicada. Finalmente se podria imprimir todas las palabras existentes en el arbol ordenadas por su longitud, para hacer esto se tendria que recorrer el arbol y guardar en una lista las palabras, ademas de ordenarlas, para luego imprimirlas.",
    "Tenemos un mapa de empleados, cada uno con una lista de proyectos en los que han trabajado y el tiempo que dedicaron a cada uno. ¿Cómo podría implementar una función para encontrar el empleado que ha dedicado más tiempo a los proyectos?",
    "Primero que todo, se tendria que recorrer el mapa, para obtener no solo los empleados, si no que sus proyectos y el tiempo que les han dedicado, se podria usar una variable que calcule cual es el mayor tiempo maximo encontrado, ademas de guardar en otra variable el empleado que logro ese tiempo y el proyecto en el que lo hizo. Con esto, puedes recorrer todo el mapa, y si encuentras un tiempo mayor al anterior registrado, actualizas ambas variables con los datos nuevos.",
    "Describe el algoritmo de búsqueda en anchura (BFS, por sus siglas en inglés) en un grafo, utilizando una cola.",
    "La búsqueda en anchura (o BFS) es un algoritmo de tipo FIFO (First In, First Out) el cual busca los nodos de cierto nivel antes de pasar al siguiente, buscando los caminos mas \"cortos\" entre nodos. Para poder implementar esto en una cola, se podria hacer lo siguiente:\n\nSe inicia la cola estando vacia, y despues se le añade el nodo inicial, luego de eso se puede iniciar un conjunto que añada los nodos visitados, y que añada al nodo inicial. El siguiente paso seria recorrer toda la cola hasta que esta quede vacia, es decir sacar el primer nodo de la cola para despues procesar el nodo actual según sea necesario. Obtener todos los vecinos no visitados del nodo actual y para cada uno de estos marcarlo como visitado y agregarlo a la cola. Es necesario calcar que a pesar de ser una excelente forma de recorrer la cola y el grafo, no es necesariamente la forma más optima de lograr una busqueda."
],[
    "ABARCA PEZO",
    "FRANCISCA ANTONIA",
    "franciscabarca1@gmail.com",
    "Finalizado",
    "19 de mayo de 2023  14:25",
    "19 de mayo de 2023  14:55",
    "30 minutos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos con la misma prioridad se procesan en orden de llegada",
    "Verdadero",
    "En un árbol B, se puede tener más de un valor asociado a una misma clave",
    "Verdadero",
    "Un grafo es útil cuando queremos encontrar la ruta más corta entre dos nodos, ya que los algoritmos de búsqueda de caminos en grafos son muy eficientes",
    "Verdadero",
    "En un montículo binario, la búsqueda de un elemento se realiza en tiempo constante",
    "Falso",
    "En un árbol B, el número de claves en cada nodo es fijo",
    "Falso",
    "La búsqueda en profundidad es más eficiente que la búsqueda en anchura en grafos profundos.",
    "Falso",
    "A diferencia de los arreglos ordenados, las tablas hash pueden tener un tiempo de acceso constante para la búsqueda de elementos",
    "Verdadero",
    "La inserción en un montículo tiene complejidad O(log n) en el peor de los casos, ya que debemos asegurarnos de mantener la propiedad del montículo al acomodar los elementos",
    "Verdadero",
    "La complejidad temporal de la inserción en un árbol B es O(n) debido a que se deben realizar varias divisiones y fusiones de nodos",
    "Falso",
    "Describa cómo se puede utilizar un conjunto o mapa para verificar si una lista tiene elementos duplicados.",
    "se podría utilizar como un mapa, ya que para verificar los elementos duplicados es conveniente. Inicializa un conjunto vacío o un mapa vacío, dependiendo de si se desea simplemente verificar duplicados o también rastrear la frecuencia de los elementos duplicados. Recorre la lista elemento por elemento. Para cada elemento de la lista, verifica si ya está presente en el conjunto o mapa utilizando la operación de búsqueda (como \"contains\" en un conjunto o verificar si la clave existe en el mapa).\n\nSi el elemento ya está presente, significa que hay un duplicado en la lista. Puedes tomar acciones como terminar la verificación y reportar el resultado o llevar un registro de los elementos duplicados y su frecuencia en el mapa.\n\nSi el elemento no está presente, agrégalo al conjunto o mapa.\n\nUna vez que se ha recorrido toda la lista, se habrá verificado si hay duplicados. El conjunto o mapa contendrá todos los elementos únicos de la lista, y se puede consultar para obtener información adicional, como la frecuencia de los elementos duplicados.",
    "Considere que tenemos un mapa de estudiantes, donde cada estudiante tiene una lista de cursos y las notas obtenidas en cada curso. ¿Cómo podría implementar una función para encontrar el curso en el que los estudiantes tienen el promedio de notas más bajo?",
    "Para implementar una función que encuentre el curso en el que los estudiantes tienen el promedio de notas más bajo en un mapa de estudiantes, primeramente recorre el mapa de estudiantes y obtén la lista de cursos y notas de cada estudiante.\n\nInicializa un diccionario vacío llamado PROMEDIOS para almacenar el promedio de notas de cada curso. Luego, calcula el promedio de notas para cada curso. Puedes hacerlo iterando sobre la lista de cursos y notas de cada estudiante.\n\nActualiza el diccionario PROMEDIOS con el promedio de notas de cada curso.\n\nEncuentra el curso con el promedio de notas más bajo. Puedes usar la función MIN  en el diccionario PROMEDIOS para obtener la clave (curso) con el valor mínimo (promedio de notas más bajo). Finalmente, devuelve el curso con el promedio de notas más bajo.",
    "Considere que tenemos un mapa de tareas, en donde cada tarea tiene una lista de tareas precedentes. Describa un algoritmo que imprima las tareas en un orden en que puedan realizarse (tomando en cuenta relación de precedencia).",
    "-"
],[
    "ZAMORA GATICA",
    "LUCAS DANILO",
    "lzamoraga@gmail.com",
    "Finalizado",
    "19 de mayo de 2023  14:55",
    "19 de mayo de 2023  15:21",
    "26 minutos 8 segundos",
    "Sin calificar aún",
    "Las colas con prioridad pueden ser implementadas utilizando diferentes estructuras de datos, como montículos o listas enlazadas",
    "Verdadero",
    "El árbol B\/B+ es útil para el almacenamiento y recuperación eficiente de grandes cantidades de datos en disco, ya que minimiza las operaciones de lectura\/escritura y reduce el tiempo de acceso a los datos",
    "Verdadero",
    "Es útil usar grafos para mantener datos ordenados por claves y realizar búsquedas por prioridad.",
    "Falso",
    "En un montículo binario, la inserción de un nuevo elemento siempre se realiza en la hoja más profunda del árbol, y luego se reordena el árbol hacia arriba para mantener la propiedad de ordenación",
    "Falso",
    "En un árbol B, la operación de búsqueda tiene una complejidad de tiempo constante, independientemente del número de elementos almacenados en el árbol",
    "Verdadero",
    "La búsqueda en anchura es una buena opción para grafos con una profundidad desconocida.",
    "Verdadero",
    "Las listas enlazadas son más eficientes que los arreglos para insertar o eliminar elementos en posiciones aleatorias de la estructura",
    "Verdadero",
    "La complejidad espacial de un montículo binario es O(n), ya que todos los elementos se almacenan en el árbol",
    "Verdadero",
    "Un árbol B+ tiene una altura de entre 2 y 5 niveles.",
    "Falso",
    "Suponga que tiene un conjunto de operaciones a realizar, cada una con un tiempo de duración diferente. ¿Cómo podría usar una cola de prioridad para ordenar las operaciones de manera que se realicen primero las más cortas?",
    "Se puede guardar cada tiempo en una struct el nombre de la operación seria el dato asociado\n\nIngresaría los el primer tiempo dentro de la cola, la prioridad de la cola serian los tiempos de duración (menor tiempo mayor prioridad), y luego se extraería el primer elemento de la cola que seria la operación con menor duración.",
    "Tenemos un mapa de artistas. Cada artista, además del nombre, tiene una lista de géneros musicales asociados (rock, pop, jazz, clásico, etc.) ¿Cómo podríamos imprimir el número de artistas asociados a cada género, indicando el género más popular?",
    "Crearía un mapa Inverso, donde las claves serian los generos y el dato seria una lista de los artista en los que aparece el genero\nSe recorre  la lista de géneros musicales asociado de cada artista, luego se busca en el mapa inverso si el genero esta como clave. \n\nSi no esta significa que hasta ahora no hay ningun artista con ese genero, por lo que se inserta el genero y se guarda el artista en su lista. \n\nSi esta significa que ya hay un artista con ese genero, por lo que solo se agrega el nombre del artista a la lista de artistas.\n\nAl final solo habria que imprimir cada elemento del mapa inverso , e imprimir sus listas de artistas, con un contador de artistas.\n\nLa clave con el  contador de artistas mas alto es el genero mas popular",
    "Describe el algoritmo de búsqueda en anchura (BFS, por sus siglas en inglés) en un grafo, utilizando una cola.",
    "BFS realiza una búsqueda en achura explorando todos los vecinos de un nodo antes de pasar a los nodos vecinos del nivel siguiente.\n\nCon esto en mente la cola almacenaría los nodos a visitar, entonces cuando se encuentre el dato a buscar, en la cola se guardaría el camino mas corto al dato."
],[
    "KERMANI ORDENES",
    "KAVON EBRAHIM",
    "kavon.kermani.o@mail.pucv.cl",
    "Finalizado",
    "18 de mayo de 2023  12:18",
    "18 de mayo de 2023  12:40",
    "22 minutos 37 segundos",
    "Sin calificar aún",
    "Se puede utilizar colas con prioridad para reducir el tiempo de espera promedio de los clientes de un servicio",
    "Verdadero",
    "Los árboles B+ son utilizados para mejorar el rendimiento de la búsqueda secuencial en disco",
    "Verdadero",
    "Se puede usar grafos para modelar sistemas de recomendación, como en aplicaciones de comercio electrónico o de películas, ya que los grafos pueden representar las preferencias de los usuarios y las relaciones entre productos o películas",
    "Verdadero",
    "En un montículo binario de máximos, el elemento de mayor valor siempre se encuentra en la raíz del árbol, por lo que la eliminación de este elemento implica reorganizar el árbol para mantener la propiedad de ordenación.",
    "Verdadero",
    "En un árbol B+, las hojas contienen todos los datos almacenados en el árbol, mientras que los nodos internos solo contienen claves para dividir los datos en subárboles",
    "Falso",
    "La búsqueda en anchura utiliza una cola para almacenar los nodos a visitar.",
    "Verdadero",
    "Los arreglos ordenados son más eficientes que las listas enlazadas para buscar elementos en la estructura",
    "Verdadero",
    "El orden en que se ingresan los elementos en un montículo binario no afecta su complejidad temporal, ya que siempre se cumple la propiedad del montículo",
    "Verdadero",
    "La complejidad espacial de un árbol B+ es mayor que la de un árbol B debido a que los nodos internos almacenan más claves.",
    "Falso",
    "Imagina que tienes un mapa con las calificaciones de los estudiantes, donde la clave es el nombre del estudiante y el valor es su calificación. ¿Cómo podrías implementar una función para encontrar a todos los estudiantes que aprobaron (calificación mayor a 5)?",
    "Se puede implementar mediante una tabla hash con el nombre de los estudiantes como clave y su respectivo calificación como el dato. Como no necesariamente tiene que estar ordenado este mapa, se puede hacer una búsqueda con el dato de cada elemento de la tabla (por que es eficiente de todas formas con su compeljidad temporal o(1)), y comparar si el dato buscado es mayor a 5.",
    "Considere que tenemos un mapa de estudiantes, donde cada estudiante tiene una lista de asignaturas. Cada asignatura tiene una lista de calificaciones. ¿Cómo podría implementar una función para calcular el promedio general de cada estudiante?",
    "Con la lista que se tiene de cada estudiante, se obtiene el dato de la calificación de cada elemento de la lista y se recorre haciendo una suma de todo ellos donde se retornaria esa suma dividido por el largo de la lista. Y así sucesivamente para cada estudiante.",
    "Diseña un algoritmo que permita verificar si un grafo es un árbol utilizando DFS o BFS.",
    "Se puede implementar una lista con los nodos visitados, y se elige un nodo inicial para agregarlo a esa estructura. Se inicia el recorrido con el DFS con la pila desde el nodo inicial. Mientras que hayan nodos sin visitar, se toma ese elemento y lo marca como visitado. Después se recorre todos los nodos adyacentes del nodo actual, si alguno ya fue visitado, entonces el grafo no es una árbol, ya que posee un ciclo. Si se recorren todos los nodos y no se encontraron ciclos, entonces el grafo es efectivamente un árbol."
],[
    "GUERRERO CASTILLO",
    "MATIAS IGNACIO",
    "mati.guerrerocastillo@gmail.com",
    "Finalizado",
    "19 de mayo de 2023  08:12",
    "19 de mayo de 2023  08:27",
    "15 minutos 14 segundos",
    "Sin calificar aún",
    "En una cola con prioridad, los elementos se eliminan en función de su orden de llegada",
    "Falso",
    "El árbol B\/B+ es útil para la implementación de algoritmos de búsqueda en grafos, ya que permite una rápida búsqueda de nodos y aristas",
    "Verdadero",
    "Un grafo es útil cuando queremos optimizar el flujo de recursos en una red, como el suministro de energía o la distribución de agua, ya que los algoritmos de flujo en grafos pueden encontrar la ruta más eficiente para distribuir los recursos",
    "Verdadero",
    "En un montículo binario, todos los niveles del árbol excepto posiblemente el último están completamente llenos, y los nodos del último nivel se llenan de izquierda a derecha",
    "Verdadero",
    "La operación de búsqueda en un árbol B+ implica recorrer todos los nodos hoja del árbol hasta encontrar el valor deseado",
    "Falso",
    "La búsqueda en profundidad consume más memoria que la búsqueda en anchura en grafos anchos.",
    "Verdadero",
    "A diferencia de las tablas hash, los árboles binarios no tienen un orden definido para los elementos almacenados",
    "Verdadero",
    "La búsqueda de un elemento en un montículo tiene complejidad O(n)",
    "Verdadero",
    "La búsqueda en un árbol B tiene complejidad temporal O(n), donde n es el número de elementos en el árbol.",
    "Falso",
    "¿Cómo implementaría una cola de prioridad para administrar las solicitudes de atención al cliente en un sistema de soporte técnico, donde los clientes VIP tienen la más alta prioridad, seguidos por los clientes habituales y luego los nuevos clientes?",
    "Se puede implementar una cola con prioridad utilizando 2 pilas.\n\n- Al momento de ingresar los pacientes, se ingresa el nombre del paciente y la prioridad establecida en enteros (p.ej: VIP = 1, Clientes Habituales = 2 y Nuevos clientes = 3).\n\n- Se agregan los pacientes a la pila 1.\n\n- Cada vez que se agrega un nuevo paciente se compara con la cima de la pila 1, si el paciente ingresado tiene una prioridad mayor a la cima de la pila 1, la cima se desapila y se apila a la pila 2, hasta encontrar una posicion correcta en la cola de prioridad.\n\n- Luego se desapilan todos los datos de la pila 2, y se vuelven a apilar a la 1.\n\n- Para la Eliminacion, se debe pasar toda la pila 1 a la pila 2, y posteriormente ir eliminando la cima de esta.",
    "Supongamos que tenemos un mapa de autores, donde cada autor tiene una lista de libros que ha escrito. Cada libro incluye título, género y calificación promedio. ¿Cómo implementarías una función para calcular la calificación promedio de los libros del género de aventuras?",
    "- Se crea una lista vacia para guardar las calificaciones promedio de cada libro del genero de aventura.\n\n- Ademas se crea un contador que aumenta cada vez que se agrega una calificacion a la lista de calificaciones anterior.\n\n- Luego se recorre el mapa, y para cada autor se recorre su lista de libros, para cada libro del genero de aventura se guarda su calificacion.\n\n- Por ultimo se suman todas las calificaciones de la lista de calificaciones y se divide en el contador de libros guardados.",
    "Explique cómo podría implementar una cola con prioridad, usando 2 pilas. ¿Como realizaría inserciones y eliminaciones en la cola con prioridad?",
    "- Para agregar elementos se insertan en la pila 1. En cada insercion se compara la cima de la pila 1 con el elemento a insertar, si el elemento tiene menor prioridad simplemente se apila, sino, se debe desapilar la cima y apilarlo en la pila 2 hasta encontrar una posicion correcta. Cuando se encuentra una posicion correcta se desapilan todos los elementos de la pila 2 y se vuelven a apilar a la 1.\n\n- Para la eliminacion, se deben apilar todos los elementos de la pila 1 a la 2, e ir eliminando la cima de la pila 2, ya que quedarian de forma ordenada por prioridad, siendo la cima la prioridad mas alta."
],[
    "NORDENFLYCHT LUBBERT",
    "PEDRO JESUS",
    "pedronorden@gmail.com",
    "Finalizado",
    "18 de mayo de 2023  12:24",
    "18 de mayo de 2023  12:42",
    "18 minutos 21 segundos",
    "Sin calificar aún",
    "Se puede usar colas con prioridad para almacenar los nodos en un algoritmo de búsqueda en grafos",
    "Verdadero",
    "El árbol B\/B+ es útil para la implementación de bases de datos, ya que permite una rápida recuperación de datos y una fácil actualización de los mismos",
    "Verdadero",
    "Se puede usar grafos para modelar relaciones y conexiones entre elementos, como redes de transporte o redes sociales, ya que los grafos permiten representar de manera clara y visual la estructura de estas conexiones y facilitan el análisis y la toma de decisiones",
    "Verdadero",
    "Un montículo binario es una estructura de datos que permite mantener una colección de elementos ordenados en función de su valor, con una complejidad de tiempo logarítmica para las operaciones de inserción, eliminación y búsqueda",
    "Falso",
    "En un árbol B, cada nivel del árbol se llena por completo antes de agregar un nuevo nivel",
    "Verdadero",
    "La búsqueda en anchura es una buena opción para grafos con una profundidad desconocida.",
    "Verdadero",
    "Los arreglos ordenados son más eficientes que las listas enlazadas para buscar elementos en la estructura",
    "Verdadero",
    "El acceso al elemento mínimo en un montículo binario de mínimos tiene complejidad temporal O(log n) ya que se debe atravesar el árbol",
    "Falso",
    "La búsqueda en un árbol B tiene complejidad temporal O(n), donde n es el número de elementos en el árbol.",
    "Falso",
    "Tenemos una lista de productos con su precio y categoría. ¿Cómo podríamos calcular el precio promedio por categoría usando un mapa?",
    "Se puede recorrer el mapa comprobando que en cada producto la categoría sea la que se quiera calcular. Si es la categoría buscada, se suma el precio a una variable que vaya sumando todos los precios y se agrega uno a un contador que cuente la cantidad de productos recorridos, si no es la categoría buscada se sigue con el próximo dato. Se realizan estos pasos en un ciclo hasta que el próximo valor del mapa sea nulo. Luego, tomamos la variable que sumaba los precios y la dividimos con el contador que contaba la cantidad de datos recorridos para finalmente tener el promedio de precio para una categoría de productos.",
    "Suponga que tiene un mapa de restaurantes, donde cada restaurante tiene una lista de platos en su menú. ¿Cómo podría imprimir todos los restaurantes que tienen \"pasta carbonara\" en su menú?",
    "Se puede guardar el menú en un mapa, donde la clave seria el nombre del plato y el valor puede ser el precio. Se tendría que recorrer el mapa de restaurantes y revisar con la función searchMap si existe el plato \"Pasta carbonara\", si es así, se muestra el nombre del restaurante y se avanza al siguiente restaurante del mapa. En caso contrario, solamente se revisa el próximo restaurante.",
    "Considere que tenemos un mapa de tareas, en donde cada tarea tiene una lista de tareas precedentes. Describa un algoritmo que imprima las tareas en un orden en que puedan realizarse (tomando en cuenta relación de precedencia).",
    "Asumiendo que cada tarea tiene su propia prioridad, podemos ingresar las tareas del mapa sin precedencia en un montículo que los ordene en base a su prioridad. Las tareas ingresadas deberán ser marcadas como visitadas. Luego, se ingresa la raíz del montículo en una nueva lista. Los datos ingresados en esta lista deberán ser marcados como explorados. Del mapa de tareas se toman las tareas cuyas precedencias estén marcadas como exploradas y se ingresan en el montículo donde nuevamente se agrega la raiz a la lista. Se repite este proceso hasta que se hayan explorado todas las tareas del mapa."
],[
    "AGUILERA ESPEJO",
    "MANUEL IGNACIO",
    "manuel.aguilera.e@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:29",
    "19 de mayo de 2023  14:43",
    "13 minutos 25 segundos",
    "Sin calificar aún",
    "Las colas con prioridad pueden ser utilizadas para el ordenamiento de elementos en un arreglo",
    "Verdadero",
    "En un árbol B, la altura máxima del árbol depende del número de claves y el orden del árbol (cantidad máxima de nodos por hoja)",
    "Verdadero",
    "Se puede usar grafos para analizar redes complejas, como la propagación de enfermedades o la interconexión de sistemas informáticos, ya que los grafos permiten modelar las interacciones entre los elementos y estudiar cómo se propagan los efectos a través de la red",
    "Verdadero",
    "En un montículo binario, la búsqueda de un elemento se realiza en tiempo constante",
    "Verdadero",
    "Un árbol B generalmente tiene una altura mayor a la de un árbol de búsqueda binaria normal",
    "Falso",
    "La búsqueda en anchura utiliza una cola para almacenar los nodos a visitar.",
    "Verdadero",
    "A diferencia de los montículos, los arreglos ordenados mantienen la posición relativa de los elementos",
    "Verdadero",
    "El orden en que se ingresan los elementos en un montículo binario no afecta su complejidad temporal, ya que siempre se cumple la propiedad del montículo",
    "Verdadero",
    "La complejidad temporal de la inserción en un árbol B es O(1)",
    "Falso",
    "Teniendo un mapa de estudiantes donde la clave es el número de matrícula y el valor es la nota final. ¿Cómo podrías calcular la nota promedio de todos los estudiantes?",
    "Tendria una variable contador, y otra sumaNotas que guarde la suma de las notas.\nLuego recorreria el mapa usando firstMap() y nextMap() al final retornaria un float sumaNotas\/contador",
    "Suponga que tiene un mapa de restaurantes, donde cada restaurante tiene una lista de platos en su menú. ¿Cómo podría imprimir todos los restaurantes que tienen \"pasta carbonara\" en su menú?",
    "Haria un recorrido del mapa usando firstMap y nextMap, luego en cada posicion de este haria un search de la lista, hasta que me devuelva el valor que busco. En este caso es un string con valor \"pasta carbonara\". El search puede que venga implementado en la lista, pero sino, tendria que hacer una busqueda lineal. Ya que la lista no esta ordenada.",
    "Explique cómo podría implementar una cola con prioridad, usando 2 pilas. ¿Como realizaría inserciones y eliminaciones en la cola con prioridad?",
    "Habria que leer cada dato almacenandolo en una pila, si entra un dato con mayor prioridad que el ultimo de la pila. Entonces habria que copiar la pila a una pila2 nivel por nivel, hasta encontrar un dato con menor o igual prioridad. Esto nos proporcionaria la posicion de nuestro valor ingresado. Asi que despues de insertar el valor ingresado en pila2, seguiriamos copiando los datos. Ahi tendriamos a pila2 con los datos ordenados al reves. Por lo que copiamos nuevamente desde pila2 hacia pila y nos quedaria la cola por prioridad ordenada.\n\nPara la eliminacion hariamos un recorrido parecido, la diferencia es que en vez de ingresar un nuevo dato a la pila2 habria que ignorarlo."
],[
    "MARTINEZ CANTO",
    "DAVID SAMUEL",
    "david.martinez.c@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  08:10",
    "19 de mayo de 2023  08:32",
    "22 minutos 23 segundos",
    "Sin calificar aún",
    "Es recomendable usar colas con prioridad cuando todos los elementos tienen la misma prioridad",
    "Falso",
    "El árbol B\/B+ es útil para la implementación de algoritmos de búsqueda en grafos, ya que permite una rápida búsqueda de nodos y aristas",
    "Falso",
    "Un grafo es útil cuando queremos optimizar el flujo de recursos en una red, como el suministro de energía o la distribución de agua, ya que los algoritmos de flujo en grafos pueden encontrar la ruta más eficiente para distribuir los recursos",
    "Verdadero",
    "Un montículo binario puede ser implementado utilizando un arreglo.",
    "Verdadero",
    "En un árbol B, cada nivel del árbol se llena por completo antes de agregar un nuevo nivel",
    "Verdadero",
    "La búsqueda en profundidad consume más memoria que la búsqueda en anchura en grafos anchos.",
    "Falso",
    "Los árboles B son más eficientes que los arreglos y las listas enlazadas para realizar búsquedas, inserciones y eliminaciones en grandes conjuntos de datos",
    "Verdadero",
    "La inserción en un montículo tiene complejidad O(log n) en el peor de los casos, ya que debemos asegurarnos de mantener la propiedad del montículo al acomodar los elementos",
    "Verdadero",
    "La inserción en un árbol B+ tiene complejidad temporal O(log n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "¿Cómo implementaría una cola de prioridad para administrar las solicitudes de atención al cliente en un sistema de soporte técnico, donde los clientes VIP tienen la más alta prioridad, seguidos por los clientes habituales y luego los nuevos clientes?",
    "una cola con prioridad implementada con un montículo binario y en cada posición del montículo  existe una lista con los clientes que tiene esa prioridad cuando se necesita atender a clientes se extrae la posición con mas prioridad y se recorre la lista para atender a los clientes, ejemplo los clientes vip tienen prioridad 3 los habituales tienen prioridad 2 y los nuevos clientes prioridad 1,al extraer se va a extraer la lista con los clientes vip (si es que existen, en caso contrario se extraerá la siguiente prioridad)y cuando se termine con ellos siguen los clientes habituales ,así sucesivamente hasta que el montículo este vacío",
    "Considere que tenemos un mapa de estudiantes, donde cada estudiante tiene una lista de cursos y las notas obtenidas en cada curso. ¿Cómo podría implementar una función para encontrar el curso en el que los estudiantes tienen el promedio de notas más bajo?",
    "se crea una lista en la que cada elemento tiene asociado el nombre del curso ,el promedio de ese curso, la suma de las notas de cada estudiante y la cantidad de estudiantes con ese curso\n\nse recorre el mapa con las funciones first y next ,para cada estudiante se verifica la lista de los cursos y se agrega el curso a la lista que nosotros creamos (si es que no existe en nuestra lista),se saca el promedio de las notas obtenidas por el alumno que estamos viendo y se suma a nuestra lista(en la variable suma de las notas de cada estudiante)también se aumenta la cantidad de estudiantes que tienen este curso y se pasa al siguiente estudiante repitiendo este ejercicio hasta llegar al final del mapa.\n\nposteriormente se llena la variable promedio del curso (en nuestra lista),después de hacer esto se recorre nuestra lista buscando el menor promedio",
    "Describa un algoritmo para implementar una pila utilizando dos colas.",
    "-"
],[
    "BARRETO HORN",
    "ULYSSES EDWARD",
    "ulysses.barreto.h@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  14:32",
    "19 de mayo de 2023  14:42",
    "10 minutos 8 segundos",
    "Sin calificar aún",
    "Las colas con prioridad pueden ser implementadas utilizando diferentes estructuras de datos, como montículos o listas enlazadas",
    "Verdadero",
    "En un árbol B, la altura máxima del árbol depende del número de claves y el orden del árbol (cantidad máxima de nodos por hoja)",
    "Verdadero",
    "Se puede usar grafos para modelar redes de transporte, como el tráfico de carreteras o el transporte aéreo, ya que los grafos permiten representar la estructura de las conexiones y las relaciones entre ellas",
    "Verdadero",
    "Un montículo binario solo puede ser utilizado para elementos de tipo numérico, ya que la propiedad de ordenación se basa en la comparación de valores numéricos",
    "Verdadero",
    "Para eliminar un dato en un árbol B, basta con buscar la clave y eliminarla del nodo correspondiente. Si el nodo se queda sin claves, debemos realizar una fusión.",
    "Falso",
    "La búsqueda en profundidad consume más memoria que la búsqueda en anchura en grafos anchos.",
    "Falso",
    "A diferencia de las tablas hash, los árboles binarios no tienen un orden definido para los elementos almacenados",
    "Falso",
    "El acceso al elemento mínimo en un montículo binario de máximos tiene complejidad O(log n), ya que se debe descender por el árbol hasta llegar al nodo hoja más a la izquierda",
    "Verdadero",
    "La complejidad espacial de un árbol B es O(n log n)",
    "Verdadero",
    "¿Cómo podríamos implementar una función que tome una lista de palabras y retorne las palabras ordenadas de acuerdo a su longitud? (use TDAs y no algoritmos de ordenamiento)",
    "usamos un montículo binario con una pila, donde se irán insertando de menor a mayor los datos en la pila y luego se mostrarán los datos de la pila que estarán ordenadas de mayor a menor acordes a su longitud",
    "Supongamos que tenemos un mapa de autores, donde cada autor tiene una lista de libros que ha escrito. Cada libro incluye título, género y calificación promedio. ¿Cómo implementarías una función para calcular la calificación promedio de los libros del género de aventuras?",
    "Se pueden guardar los autores en una tabla hash, y por cada acceso a él, se busca en la lista un libro con el género buscado y se se suma. El proceso se repite por los N autores que se encuentren.",
    "Describa un algoritmo para implementar una pila utilizando dos colas.",
    "en la primera cola se insertarían los datos por defecto, mientras que en la segunda cola se irán insertando datos de la primera, que como están en orden de first in last out, quedarán de forma ordenada \"first in first out\"."
],[
    "MIÑO SILVA",
    "MAXIMILIANO ESTEBAN",
    "maximiliano.mino.s@mail.pucv.cl",
    "Finalizado",
    "19 de mayo de 2023  08:12",
    "19 de mayo de 2023  08:42",
    "29 minutos 58 segundos",
    "Sin calificar aún",
    "Se puede usar colas con prioridad para almacenar los nodos en un algoritmo de búsqueda en grafos",
    "Verdadero",
    "Los árboles B+ son una variante de los árboles B, donde los nodos hoja contienen registros de datos",
    "Verdadero",
    "Un grafo es útil cuando queremos optimizar el flujo de recursos en una red, como el suministro de energía o la distribución de agua, ya que los algoritmos de flujo en grafos pueden encontrar la ruta más eficiente para distribuir los recursos",
    "Verdadero",
    "Un montículo binario es una estructura de datos inmutable, es decir, una vez que se crea un montículo, no se pueden realizar modificaciones en su contenido",
    "Falso",
    "Un árbol B generalmente tiene una altura mayor a la de un árbol de búsqueda binaria normal",
    "Falso",
    "La búsqueda en anchura es una buena opción para grafos con una profundidad desconocida.",
    "Falso",
    "Los arreglos son más eficientes que las listas enlazadas para acceder al i-ésimo elemento",
    "Verdadero",
    "La búsqueda de un elemento en un montículo tiene complejidad O(n)",
    "Falso",
    "La complejidad temporal de la búsqueda en un árbol B es O(log n), donde n es el número de elementos en el árbol.",
    "Verdadero",
    "Tenemos una lista de personas con su nombre y país de origen. ¿Cómo podríamos agrupar a las personas por país utilizando un mapa?",
    "usaremos una tabla hash cuya clave para poder acceder a los datos sea su país de origen, mientras que los datos almacenados sea una lista de las personas procedentes de ese país",
    "Supongamos que tenemos un mapa de estudiantes donde la clave es el ID del estudiante y el valor es una lista de asignaturas en las que se ha inscrito. ¿Cómo implementarías una función para eliminar una asignatura?",
    "Antes de comenzar con el grueso de la función, debemos tener una cierta cantidad de  variables principales, que serán el mapa, el id del alumno y la asignatura que vamos a eliminar.\n\ncomenzaremos haciendo una búsqueda del alumno a través de un searchMap del mapa y la id del alumno, si no se encuentra, dejamos un mensaje de que el alumno no existe y nos salimos de la función, en caso contrario, usaremos una lista auxiliar que será la lista de las asignaturas guardadas en el mapa. Luego se recorrerá el mapa comparando el nombre de la asignatura que esta en la lista con el nombre de la asignatura que vamos a eliminar, si se llega a encontrar, se dará un mensaje que avisara al usuario que se encontró y elimino la asignatura, si ya recorrimos toda la lista y no se encontró la asignatura, procedemos a avisar de que tal alumno no tiene esa asignatura.",
    "Explica un algoritmo para implementar una cola utilizando dos pilas.",
    "para poder implementar una cola a través de 2 pilas, debemos tener en consideración que las funciones de inserción y eliminación se deben de mover todos los datos para poder realizar tales funciones (teniendo en consideración que no se usan nodos), es por eso que se requieren 2 pilas, 1 que será la pila principal y otra que será un auxiliar que guardara el principal para colocarlo en otra posición."
],[
    "CASTRO ROJAS",
    "MATIAS EXEQUIEL",
    "matias.castro.r@mail.pucv.cl",
    "Finalizado",
    "18 de mayo de 2023  12:19",
    "18 de mayo de 2023  12:38",
    "18 minutos 43 segundos",
    "Sin calificar aún",
    "Se puede usar colas con prioridad para almacenar los nodos en un algoritmo de búsqueda en grafos",
    "Verdadero",
    "El árbol B\/B+ es útil para el almacenamiento y recuperación eficiente de grandes cantidades de datos en disco, ya que minimiza las operaciones de lectura\/escritura y reduce el tiempo de acceso a los datos",
    "Verdadero",
    "Se puede usar grafos para modelar redes de transporte, como el tráfico de carreteras o el transporte aéreo, ya que los grafos permiten representar la estructura de las conexiones y las relaciones entre ellas",
    "Verdadero",
    "Al igual que un montículo, un árbol AVL también se podría implementar usando un arreglo.",
    "Verdadero",
    "La operación de búsqueda en un árbol B+ implica recorrer todos los nodos hoja del árbol hasta encontrar el valor deseado",
    "Verdadero",
    "La búsqueda en profundidad puede ser implementada de manera recursiva.",
    "Verdadero",
    "Los árboles B son ideales para el acceso secuencial de datos",
    "Verdadero",
    "Un montículo binario puede tener múltiples elementos con el mismo valor",
    "Falso",
    "La complejidad temporal de la inserción en un árbol B es O(1)",
    "Falso",
    "Tenemos una lista de personas con su nombre y país de origen. ¿Cómo podríamos agrupar a las personas por país utilizando un mapa?",
    "usaríamos un mapa que cada casilla tenga listas, las claves serian el país de origen y las listas de la casilla guardarían los nombres de las personas",
    "Supongamos que tenemos un mapa de autores, donde cada autor tiene una lista de libros que ha escrito. Cada libro incluye título, género y calificación promedio. ¿Cómo implementarías una función para calcular la calificación promedio de los libros del género de aventuras?",
    "podríamos implementar otro mapa donde las claves serian el género y las casillas tengan una lista de los promedios, luego implementamos otra función la cual a partir de la lista saca el promedio.\n\nun ejemplo de la implementación para sacar el promedio seria que, primero hago un contador de los promedios guardados en la lista, luego sumo todos los promedio y los divido por el contador.",
    "Explique cómo podría implementar una cola con prioridad, usando 2 pilas. ¿Como realizaría inserciones y eliminaciones en la cola con prioridad?",
    "para la inserción ocupo la primera pila para guardar el dato, luego, en el caso que sea de mayor a menor, puedo ocupar la segunda pila para ir guardando en orden, es decir, voy jugando entre la primera y la segunda cola para ir guardando.\nejemplo: la primera cola guarda el dato, luego reviso si el dato de la otra cola es menor, en caso de que sea menor las intercambio.\n\npara la eliminación seria algo similar a la inserción\n\nejemplo: tengo un auxiliar que guarda el dato a eliminar, luego le voy pasando los datos de una cola a otra hasta encontrar el dato a eliminar, si no lo encuentra, se restablece la segunda pila"
]]]